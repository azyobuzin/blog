{"componentChunkName":"component---src-templates-tag-js","path":"/tags/C#/","result":{"data":{"site":{"siteMetadata":{"title":"あじょろぐ","siteUrl":"https://blog.azyobuzi.net"}},"allBlogPost":{"edges":[{"node":{"preamble":"<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>また TPL Dataflow の話です。突然ですが、バッファのない PropagatorBlock って欲しくないですか？</p>\n</div>\n<div class=\"paragraph\">\n<p>例えば、複数の SourceBlock があって、それをひとつの SourceBlock として返したいとき。</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"undefined highlight\"><code data-lang=\"cs\"><span class=\"hljs-function\">ISourceBlock&lt;T&gt; <span class=\"hljs-title\">CreateSource</span>(<span class=\"hljs-params\"></span>)</span>\n{\n    IEnumerable&lt;ISourceBlock&lt;T&gt;&gt; sources = <span class=\"hljs-comment\">/* ... */</span>;\n\n    <span class=\"hljs-keyword\">var</span> resultBlock = <span class=\"hljs-keyword\">new</span> BufferBlock&lt;T&gt;(<span class=\"hljs-keyword\">new</span> DataflowBlockOptions() { BoundedCapacity = <span class=\"hljs-number\">1</span> });\n    <span class=\"hljs-keyword\">foreach</span> (<span class=\"hljs-keyword\">var</span> s <span class=\"hljs-keyword\">in</span> sources) s.LinkTo(resultBlock);\n\n    <span class=\"hljs-keyword\">return</span> resultBlock;\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>どうでしょう？ <code>resultBlock</code> は、1件はバッファに持ってしまうので、後段のブロックがどうであれ、ソースからは必ず1件多く取り出されてしまいます。</p>\n</div>\n<div class=\"paragraph\">\n<p>1件くらいいいじゃない？ それは <code>sources</code> 次第でしょう。</p>\n</div>\n<div class=\"paragraph\">\n<p>というわけで、本題のバッファのない PropagatorBlock が欲しい、ということです。もし <code>resultBlock</code> にバッファがなければ、 <code>CreateSource</code> の戻り値を利用する（リンクする）とき、初めて <code>sources</code> からデータが取り出されます。やりたいですね。</p>\n</div>\n</div>\n</div>","slug":"2021-03-23-01-dataflowblock-without-buffer","title":"バッファのない PropagatorBlock はつくれないという話","pubdate":"2021-03-23T03:44+09:00","revdate":"2021-03-23T03:44:04+09:00","keywords":["C#"]}},{"node":{"preamble":"<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>開発環境を Docker でいい感じにしてくれるやつとして、 Visual Studio では「コンテナー開発ツール」が、 Visual Studio Code には Remote 拡張があります。これらは Dockerfile や docker-compose.yml を用意すると、その中でアプリを動かすことができるやつです。しかし、同じものではないので、挙動はまったく異なります。それぞれメリット、デメリットがあるので、両方使えるとうれしいわけです。そこで、うまいこと両方で使える docker-compose.yml を書いてみようという試みをやっていきます。</p>\n</div>\n</div>\n</div>","slug":"2020-09-28-01-vs-docker-compose","title":"Visual Studio と VSCode どちらでも使える Docker Compose 環境","pubdate":"2020-09-28T02:29+09:00","revdate":"2020-09-28T02:34:47+09:00","keywords":["C#","Docker"]}},{"node":{"preamble":"<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>複数のプロジェクトをひとつのリポジトリで管理するとき、プロジェクト間の参照関係は csproj に <code>&lt;ProjectReference&gt;</code> を書くわけですが、ここで、このプロジェクトを NuGet パッケージ化するときのことを考えます。例えば、 A と B というプロジェクトがあり、 B が A に依存しているとします。このとき B を <code>dotnet pack</code> してできあがるパッケージの A への依存はどのようになるでしょうか？ 実際にやってみると、現在の A のバージョン<strong>以上</strong>という依存関係になります。</p>\n</div>\n<div class=\"paragraph\">\n<p>ここで、 A の現在のバージョンを 1.0.0 とします。 Semantic Versioning に従っていると考えると、もし 2.0.0 がリリースされたら、破壊的な変更が入っているかもしれません。それでも B から A への依存は 1.0.0 <strong>以上</strong>で良いのでしょうか？ と考えると、「以上」以外の柔軟な依存関係を指定したくなりませんか？ というわけで、 <code>&lt;ProjectReference&gt;</code> を使ったプロジェクト間参照で、柔軟なバージョン範囲指定をしたいというのが今回のお話です。</p>\n</div>\n</div>\n</div>","slug":"2020-05-03-01-projectref","title":"ProjectReference にバージョン範囲を指定したい","pubdate":"2020-05-03T04:07+09:00","revdate":"2020-05-03T04:12:42+09:00","keywords":["C#"]}},{"node":{"preamble":"<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>以前、<a href=\"https://azyobuzin.hatenablog.com/entry/2019/05/26/164155\">「いまさら使う TPL Dataflow」</a>で紹介した TPL Dataflow は、入力されたデータを並列に処理するプログラムを、ブロックの組み合わせで簡単に記述できるライブラリです。\n<a href=\"https://azyobuzin.hatenablog.com/entry/2019/05/26/164155#%E9%A1%9E%E4%BC%BC%E5%93%81%E3%81%A8%E3%81%AE%E6%AF%94%E8%BC%83\">「類似品との比較」</a>で述べたように、 TPL Dataflow は、プッシュ型とプル型の両方の性質を持っており、送信者（<em>Producer</em>）が、受信者（<em>Consumer</em>）が処理しきれないほど大量のデータをプッシュしようとするとき、受信者がそのデータの受信を遅延させることで、データフロー内を流れるデータ量を制御します。</p>\n</div>\n<div class=\"paragraph\">\n<p>一方で、このような、大量のデータや時系列データ（イベント列）を入力し、データフロー内を流れるデータ量を制御しながら、並列にデータを加工する仕組みは、一般的に、特に Java のコミュニティでは <a href=\"https://www.reactive-streams.org/\">Reactive Streams</a> と呼ばれています。 Reactive Streams に用いられるインターフェイスは Java 9 で <code>java.util.concurrent.Flow</code> として標準ライブラリ入りしており、 RxJava や Akka Streams がこのインターフェイスの実装を提供しています（実際には、互換性のため <a href=\"https://github.com/reactive-streams/reactive-streams-jvm\">reactive-streams パッケージ</a>を通じて実装しています）。</p>\n</div>\n<div class=\"paragraph\">\n<p>C# においても Reactive Streams は他人事ではなく、 <code>java.util.concurrent.Flow</code> と同様のインターフェイスが <a href=\"https://github.com/reactive-streams/reactive-streams-dotnet\">Reactive.Streams パッケージ</a>として NuGet で配布されており、標準的なインターフェイスの座を狙っています。また Akka.NET Streams がこのインターフェイスの実装を提供しています。</p>\n</div>\n<div class=\"paragraph\">\n<p>いずれの方法も、 Reactive Extensions (Rx) 的なプッシュ型に対して、流量制限（back pressure）を導入することで、データ量を制御しています。この記事では、 Reactive Streams と TPL Dataflow をプロトコル（インターフェイスとその実装方法）から比較します。</p>\n</div>\n</div>\n</div>","slug":"2020-04-30-01-reactivestreams","title":"プロトコルから比較する Reactive Streams と TPL Dataflow","pubdate":"2020-04-30T02:36+09:00","revdate":"2020-04-30T23:03:02+09:00","keywords":["C#"]}}]}},"pageContext":{"tag":"C#"}},"staticQueryHashes":["2274497578","446747883"]}