<!DOCTYPE html><html lang="ja" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="generator" content="https://github.com/azyobuzin/blog"><link rel="stylesheet" href="https://unpkg.com/fork-awesome@~1.2.0/css/fork-awesome.min.css" crossorigin="anonymous" referrerpolicy="no-referrer"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&#x26;family=Roboto:ital,wght@0,300;0,400;0,700;1,300;1,700&#x26;display=swap" crossorigin="anonymous" referrerpolicy="no-referrer"><link rel="stylesheet" href="/global.css"><meta property="og:site_name" content="あじょろぐ"><meta name="twitter:card" content="summary"><meta name="twitter:creator" content="@azyobuzin"><title>Xamarin.Android アプリが例外で落ちるということ | あじょろぐ</title><link rel="canonical" href="https://blog.azyobuzi.net/2021/08/28/01-xaexception/"><meta property="og:title" content="Xamarin.Android アプリが例外で落ちるということ"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.azyobuzi.net/2021/08/28/01-xaexception/"><meta property="og:description" content="TL;DR: Xamarin.Android のグローバル例外ハンドラは AppDomain.UnhandledException。これで Java の例外も拾えます。ただし、例外が発生したスレッドによってはうまく拾えないケースがあり、現在修正中です（xamarin-android#6211）。"><meta property="og:article:published_time" content="2021-08-27T03:24+09:00"><meta property="og:article:modified_time" content="2021-09-24T23:30:48+09:00"><meta property="og:article:tag" content="tech"><meta property="og:article:tag" content="C#"><meta property="og:article:tag" content="Android"></head><body><div class="container"><article class="article-page"><header><h1>Xamarin.Android アプリが例外で落ちるということ</h1><div class="article-meta"><i class="fa fa-pencil-square-o" aria-hidden="true" title="公開日"></i><span class="sr-only">公開日</span> <time datetime="2021-08-27T03:24+09:00" title="公開: 2021/08/27 03:24
最終更新: 2021/09/24 23:30">2021/08/27</time> ― <a href="https://github.com/azyobuzin/blog/commits/f65f19fde91f122e1a22aef151d43393af580acb/posts/2021/08/28/01-xaexception" rel="external">History</a></div><div class="article-meta"><i class="fa fa-tags" aria-hidden="true" title="タグ"></i><span class="sr-only">タグ</span> <a class="button button-outline article-tag" href="/tags/tech/">tech</a> <a class="button button-outline article-tag" href="/tags/C%23/">C#</a> <a class="button button-outline article-tag" href="/tags/Android/">Android</a></div></header><div class="article-content"><p>TL;DR: Xamarin.Android のグローバル例外ハンドラは <code>AppDomain.UnhandledException</code>。これで Java の例外も拾えます。ただし、例外が発生したスレッドによってはうまく拾えないケースがあり、現在修正中です（<a href="https://github.com/xamarin/xamarin-android/issues/6211">xamarin-android#6211</a>）。</p>
<h2>はじめに</h2>
<p>ハンドルされない例外は、アプリにとって異常事態ですから、さっさと<a href="https://github.com/xamarin/xamarin-android/blob/916d24b7d83a79853dd1d1cf060d327f98c46e77/src/java-runtime/java/mono/android/Seppuku.java">切腹</a>する必要があります。 Xamarin.Android アプリでは、 Java の例外と .NET の例外が入り混じり、境界ではそれぞれの例外に相互変換されています。では、相互変換を繰り返し、最終的に誰にもキャッチされなかった例外は、どのように処理されるのでしょうか？ そして、もし最後の砦、グローバル例外ハンドラを設定するなら、どこに設定するのが良いのでしょうか？</p>
<h2>普通の Android アプリの死に方</h2>
<p>まずはピュア Java の Android アプリを例外で落としてみましょう。適当な場所に <code>throw new RuntimeException();</code> と書けばいいだけですね。今回は <code>MainActivity.onStart</code> に仕込んでみます。これで起動した瞬間に落ちるはずです。</p>
<p>実行するとアプリが終了し、 logcat にはこのようなログが残ります。</p>
<pre><samp class="language-samp">E AndroidRuntime: FATAL EXCEPTION: main
E AndroidRuntime: Process: com.example.ochiruapplication, PID: 6823
E AndroidRuntime: java.lang.RuntimeException
E AndroidRuntime:        at com.example.ochiruapplication.MainActivity.onStart(MainActivity.java:18)
E AndroidRuntime:        at android.app.Instrumentation.callActivityOnStart(Instrumentation.java:1425)
E AndroidRuntime:        at android.app.Activity.performStart(Activity.java:7825)
E AndroidRuntime:        at android.app.ActivityThread.handleStartActivity(ActivityThread.java:3294)
E AndroidRuntime:        at android.app.servertransaction.TransactionExecutor.performLifecycleSequence(TransactionExecutor.java:221)
E AndroidRuntime:        at android.app.servertransaction.TransactionExecutor.cycleToPath(TransactionExecutor.java:201)
E AndroidRuntime:        at android.app.servertransaction.TransactionExecutor.executeLifecycleState(TransactionExecutor.java:173)
E AndroidRuntime:        at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:97)
E AndroidRuntime:        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2016)
E AndroidRuntime:        at android.os.Handler.dispatchMessage(Handler.java:107)
E AndroidRuntime:        at android.os.Looper.loop(Looper.java:214)
E AndroidRuntime:        at android.app.ActivityThread.main(ActivityThread.java:7356)
E AndroidRuntime:        at java.lang.reflect.Method.invoke(Native Method)
E AndroidRuntime:        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)
E AndroidRuntime:        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930)
</samp></pre>
<p>さて、例外の中身を知っているのは例外を起こしたプロセスだけですから、このログを吐き出した犯人を探すことで、 Android のグローバル例外ハンドラを探すことができそうです。 <a href="https://cs.android.com/">Android Code Search</a> で「FATAL EXCEPTION」と検索すると、<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/com/android/internal/os/RuntimeInit.java;l=80;drc=56ab231a8fa86f4aa5107d9248d2cf6285469edb">それっぽい行</a>が見つかりました。</p>
<p>さらに呼び出し元を調べることで仕組みがわかります。プロセス起動時（Zygote からフォークした直後）に呼びされる <code>RuntimeInit.commonInit</code> に次のようなプログラムが入っています。</p>
<figure class="fig-code">
<figcaption><a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/com/android/internal/os/RuntimeInit.java;l=225-231;drc=56ab231a8fa86f4aa5107d9248d2cf6285469edb">RuntimeInit.commonInit の一部</a></figcaption>
<pre><code class="language-java"><span class="hljs-type">LoggingHandler</span> <span class="hljs-variable">loggingHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">LoggingHandler</span>();
RuntimeHooks.setUncaughtExceptionPreHandler(loggingHandler);
Thread.setDefaultUncaughtExceptionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">KillApplicationHandler</span>(loggingHandler));
</code></pre>
</figure>
<p>Java が管理するスレッドで発生した例外は、スレッド自体に例外ハンドラを設定していなければ <code>Thread.setDefaultUncaughtExceptionHandler</code> で設定したハンドラで処理されます。 Android では <code>RuntimeInit$KillApplicationHandler</code> が設定されており、これが最後の砦をやっています。また、 Android には Java 標準の <code>Thread</code> クラスにはない <code>setUncaughtExceptionPreHandler</code> があり、もしデフォルトのハンドラがアプリのコードによって書き換えられたとしても、 <code>RuntimeInit$LoggingHandler</code> だけは呼び出されて、 logcat に例外ログが吐きだされるようになっています。</p>
<p><code>KillApplicationHandler</code> は、 <code>ActivityManager</code> サービスに後処理（アクティビティを終了させ、必要ならばクラッシュダイアログを表示する）を任せて、プロセスを終了します。</p>
<p>まとめ: Xamarin ではないピュアな Android アプリでは、基本的にすべてのスレッドを Java が管理しているので、 <code>Thread.setDefaultUncaughtExceptionHandler</code> で設定したハンドラによって未ハンドルの例外が処理されます。 Android ではハンドラとして <code>com.android.internal.os.RuntimeInit$KillApplicationHandler</code> が設定されており、アクティビティとプロセスの終了を担っています。</p>
<h2>Xamarin アプリを例外で落とす</h2>
<p>同じことを Xamarin.Android でやってみましょう。 <code>MainActivity.OnStart</code> に <code>throw new Exception();</code> を仕込んで実行すると、このようなログが得られます。</p>
<pre><samp class="language-samp">E AndroidRuntime: FATAL EXCEPTION: main
E AndroidRuntime: Process: com.companyname.ochiruappxamarin, PID: 9701
E AndroidRuntime: java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
E AndroidRuntime: 	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:502)
E AndroidRuntime: 	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930)
E AndroidRuntime: Caused by: java.lang.reflect.InvocationTargetException
E AndroidRuntime: 	at java.lang.reflect.Method.invoke(Native Method)
E AndroidRuntime: 	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)
E AndroidRuntime: 	... 1 more
E AndroidRuntime: Caused by: java.lang.Exception
E AndroidRuntime: 	at crc64a14461782825e2ee.MainActivity.n_onStart(Native Method)
E AndroidRuntime: 	at crc64a14461782825e2ee.MainActivity.onStart(MainActivity.java:55)
E AndroidRuntime: 	at android.app.Instrumentation.callActivityOnStart(Instrumentation.java:1425)
E AndroidRuntime: 	at android.app.Activity.performStart(Activity.java:7825)
E AndroidRuntime: 	at android.app.ActivityThread.handleStartActivity(ActivityThread.java:3294)
E AndroidRuntime: 	at android.app.servertransaction.TransactionExecutor.performLifecycleSequence(TransactionExecutor.java:221)
E AndroidRuntime: 	at android.app.servertransaction.TransactionExecutor.cycleToPath(TransactionExecutor.java:201)
E AndroidRuntime: 	at android.app.servertransaction.TransactionExecutor.executeLifecycleState(TransactionExecutor.java:173)
E AndroidRuntime: 	at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:97)
E AndroidRuntime: 	at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2016)
E AndroidRuntime: 	at android.os.Handler.dispatchMessage(Handler.java:107)
E AndroidRuntime: 	at android.os.Looper.loop(Looper.java:214)
E AndroidRuntime: 	at android.app.ActivityThread.main(ActivityThread.java:7356)
E AndroidRuntime: 	... 3 more
I MonoDroid: UNHANDLED EXCEPTION:
I MonoDroid: Java.Lang.RuntimeException: java.lang.reflect.InvocationTargetException ---> Java.Lang.Reflect.InvocationTargetException: Exception of type 'Java.Lang.Reflect.InvocationTargetException' was thrown. ---> Java.Lang.Exception: Exception of type 'Java.Lang.Exception' was thrown.
I MonoDroid:   at OchiruAppXamarin.MainActivity.OnStart () [0x0000d] in &#x3C;c931122de5944a1da7dcf64a7158eefa>:0
I MonoDroid:   at Android.App.Activity.n_OnStart (System.IntPtr jnienv, System.IntPtr native__this) [0x00008] in &#x3C;db0280fb1b254cf889f3a750ac3ea0bb>:0
I MonoDroid:   at (wrapper dynamic-method) Android.Runtime.DynamicMethodNameCounter.5(intptr,intptr)
I MonoDroid:    --- End of inner exception stack trace ---
I MonoDroid:    --- End of inner exception stack trace ---
I MonoDroid:   --- End of managed Java.Lang.RuntimeException stack trace ---
I MonoDroid: java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
I MonoDroid: 	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:502)
I MonoDroid: 	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930)
I MonoDroid: Caused by: java.lang.reflect.InvocationTargetException
I MonoDroid: 	at java.lang.reflect.Method.invoke(Native Method)
I MonoDroid: 	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)
I MonoDroid: 	... 1 more
I MonoDroid: Caused by: java.lang.Exception
I MonoDroid: 	at crc64a14461782825e2ee.MainActivity.n_onStart(Native Method)
I MonoDroid: 	at crc64a14461782825e2ee.MainActivity.onStart(MainActivity.java:55)
I MonoDroid: 	at android.app.Instrumentation.callActivityOnStart(Instrumentation.java:1425)
I MonoDroid: 	at android.app.Activity.performStart(Activity.java:7825)
I MonoDroid: 	at android.app.ActivityThread.handleStartActivity(ActivityThread.java:3294)
I MonoDroid: 	at android.app.servertransaction.TransactionExecutor.performLifecycleSequence(TransactionExecutor.java:221)
I MonoDroid: 	at android.app.servertransaction.TransactionExecutor.cycleToPath(TransactionExecutor.java:201)
I MonoDroid: 	at android.app.servertransaction.TransactionExecutor.executeLifecycleState(TransactionExecutor.java:173)
I MonoDroid: 	at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:97)
I MonoDroid: 	at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2016)
I MonoDroid: 	at android.os.Handler.dispatchMessage(Handler.java:107)
I MonoDroid: 	at android.os.Looper.loop(Looper.java:214)
I MonoDroid: 	at android.app.ActivityThread.main(ActivityThread.java:7356)
I MonoDroid: 	... 3 more
I MonoDroid:
</samp></pre>
<p>見覚えのある前半と、見覚えのない後半ですね。ということは、 <code>RuntimeInit$LoggingHandler</code> は呼び出されるようです。 Java のスレッドで例外が発生しているので、 .NET の例外は JNI を通して Java 側にスローされていきます。なので Java のスレッドの例外ハンドラが処理しているのは不思議ではないですね。</p>
<p>では後半のログを出しているのは一体誰なのでしょうか？ 答えは <code>Thread.getDefaultUncaughtExceptionHandler()</code>（C# では <code>Java.Lang.Thread.DefaultUncaughtExceptionHandler</code>）を取得してみるとわかります。 Xamarin.Android の初期化メソッドが存在する <code>mono.android.Runtime</code> クラスの静的コンストラクタで、デフォルト例外ハンドラを独自に設定しています。</p>
<figure class="fig-code">
<figcaption><a href="https://github.com/xamarin/xamarin-android/blob/681887ebdbd192ce7ce1cd02221d4939599ba762/src/java-runtime/java/mono/android/Runtime.java#L13-L15">Runtime.java の一部</a></figcaption>
<pre><code class="language-java"><span class="hljs-keyword">static</span> {
    Thread.setDefaultUncaughtExceptionHandler (<span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">XamarinUncaughtExceptionHandler</span> (Thread.getDefaultUncaughtExceptionHandler ()));
}
</code></pre>
</figure>
<p>このハンドラでは、 Xamarin.Android 独自の処理をしたあと、もともと設定してあったハンドラに処理を投げています。つまり、処理順は PreHandler である <code>LoggingHandler</code> が呼び出されたあと、 Xamarin.Android 独自の処理をして、最後に <code>KillApplicationHandler</code> を実行する、という順番になります。</p>
<p>Xamarin.Android 独自の処理の中身は <a href="https://github.com/xamarin/xamarin-android/blob/ab0ed93cc88863b226c917dfef1fa62979c6ead8/src/Mono.Android/Android.Runtime/JNIEnv.cs#L284"><code>JNIEnv.PropagateUncaughtException</code></a> にあります。このメソッドの中には、ログにあった「UNHANDLED EXCEPTION」が見つけられます。また、ここで受け取った例外は <code>AppDomain.UnhandledException</code> に投げられることがわかります。</p>
<p>まとめ: Java のスレッドで発生した例外は、 Xamarin.Android 独自のハンドラで処理されます。このハンドラは <code>AppDomain.UnhandledException</code> イベントを発生させたあと、 Android の標準ハンドラである <code>KillApplicationHandler</code> を呼び出すことで Android に後片付けを任せます。</p>
<h2>.NET のスレッドで例外を起こす</h2>
<p>ここまで Java のスレッドで例外を発生させてきました。しかし、 .NET でもスレッドを作成することができます。 .NET のスレッドで例外が発生した場合はどのように処理されるのでしょうか？</p>
<p>前回の実験コードの <code>throw new Exception();</code> を <code>new Thread(() => throw new Exception()).Start();</code> に書き換えて試してみましょう。実行すると logcat のエラーログはこんな感じになりました。</p>
<pre><samp class="language-samp">F mono-rt : [ERROR] FATAL UNHANDLED EXCEPTION: System.Exception: Exception of type 'System.Exception' was thrown.
F mono-rt :   at OchiruAppXamarin.MainActivity+&#x3C;>c.&#x3C;OnStart>b__2_0 () [0x00000] in &#x3C;605572ca36544c48913788216f21b753>:0
F mono-rt :   at System.Threading.ThreadHelper.ThreadStart_Context (System.Object state) [0x00014] in &#x3C;1b39a03c32ec46258a7821e202e0269f>:0
F mono-rt :   at System.Threading.ExecutionContext.RunInternal (System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) [0x00071] in &#x3C;1b39a03c32ec46258a7821e202e0269f>:0
F mono-rt :   at System.Threading.ExecutionContext.Run (System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state, System.Boolean preserveSyncCtx) [0x00000] in &#x3C;1b39a03c32ec46258a7821e202e0269f>:0
F mono-rt :   at System.Threading.ExecutionContext.Run (System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, System.Object state) [0x0002b] in &#x3C;1b39a03c32ec46258a7821e202e0269f>:0
F mono-rt :   at System.Threading.ThreadHelper.ThreadStart () [0x00008] in &#x3C;1b39a03c32ec46258a7821e202e0269f>:0
</samp></pre>
<p>ついに Java っぽいログが出なくなりました！</p>
<p>これはどういうことかというと、何の細工もなく、 Mono がプロセスを終了しています。普通の .NET アプリと同じです。 Java 側にはまったく通達されません。</p>
<p>まとめ: .NET のスレッドで例外が発生すると Mono によってハンドルされ、普通の .NET アプリのようにプロセスが終了します。</p>
<h2>総まとめ</h2>
<p>Java が管理するスレッドで例外が発生しても、 .NET が管理するスレッドで例外が発生しても、とりあえず <code>AppDomain.UnhandledException</code> が呼び出されるので、これが最強の例外ハンドラです。</p>
<h2>おまけ: AndroidEnvironment.UnhandledExceptionRaiser って何？</h2>
<p>Xamarin.Android の例外処理を調べたことがある人は、 <code>AndroidEnvironment.UnhandledExceptionRaiser</code> が強そうな名前に見えて、使えそうに見えてしまったのではないでしょうか。しかし実際のところ、あんまり使い道はありません。</p>
<p><code>AndroidEnvironment.UnhandledExceptionRaiser</code> イベントは、 .NET で発生した例外を Java の例外に変換するときに発生します。例えば、今まで <code>OnStart</code> メソッドで <code>throw new Exception();</code> をする例を示してきましたが、 <code>OnStart</code> メソッドの呼び出し元は Java なので、 Java の例外に変換する必要があります。</p>
<p>このイベントにハンドラを設定しない場合、もしくはいずれのハンドラも <code>e.Handled = true</code> をセットしない場合はデフォルトの挙動をします。デフォルトの挙動は、 .NET の例外を <code>Android.Runtime.JavaProxyThrowable</code> でラップし、 Java を例外状態（JNI の <code>Throw</code> 関数を呼び出す）にします。</p>
<p>使い道としては、 .NET で発生した例外を握りつぶして Java のプログラムを続行させたり（<code>e.Handled = true</code> をセットして何もしない）、 <code>Android.Runtime.JavaProxyThrowable</code> ではない独自の <code>Throwable</code> に変換したり（<code>JNIEnv.Throw</code> を呼び出す）、が考えられます。</p></div></article><footer><hr><nav><a href="/">あじょろぐ</a>　|　<a href="https://twitter.com/azyobuzin" rel="author external">@azyobuzin</a></nav></footer></div></body></html>