<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[あじょろぐ]]></title><description><![CDATA[azyobuzinの進捗の証]]></description><link>https://blog.azyobuzi.net</link><generator>GatsbyJS</generator><lastBuildDate>Fri, 23 Jul 2021 07:43:15 GMT</lastBuildDate><item><title><![CDATA[バッファのない PropagatorBlock はつくれないという話]]></title><description><![CDATA[また TPL Dataflow の話です。突然ですが、バッファのない PropagatorBlock って欲しくないですか？


例えば、複数の SourceBlock があって、それをひとつの SourceBlock として返したいとき。



ISourceBlock&lt;T&gt; CreateSource()
{
    IEnumerable&lt;ISourceBlock&lt;T&gt;&gt; sources = /* ... */;

    var resultBlock = new BufferBlock&lt;T&gt;(new DataflowBlockOptions() { BoundedCapacity = 1 });
    foreach (var s in sources) s.LinkTo(resultBlock);

    return resultBlock;
}



どうでしょう？ resultBlock は、1件はバッファに持ってしまうので、後段のブロックがどうであれ、ソースからは必ず1件多く取り出されてしまいます。


1件くらいいいじゃない？ それは sources 次第でしょう。


というわけで、本題のバッファのない PropagatorBlock が欲しい、ということです。もし resultBlock にバッファがなければ、 CreateSource の戻り値を利用する（リンクする）とき、初めて sources からデータが取り出されます。やりたいですね。]]></description><link>https://blog.azyobuzi.net/2021/03/23/01-dataflowblock-without-buffer/</link><guid isPermaLink="false">https://blog.azyobuzi.net/2021/03/23/01-dataflowblock-without-buffer/</guid><category><![CDATA[C#]]></category><pubDate>Mon, 22 Mar 2021 18:44:00 GMT</pubDate><content:encoded>&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;また TPL Dataflow の話です。突然ですが、バッファのない PropagatorBlock って欲しくないですか？&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;例えば、複数の SourceBlock があって、それをひとつの SourceBlock として返したいとき。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;cs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;ISourceBlock&amp;lt;T&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;CreateSource&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;
{
    IEnumerable&amp;lt;ISourceBlock&amp;lt;T&amp;gt;&amp;gt; sources = &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt;;

    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; resultBlock = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BufferBlock&amp;lt;T&amp;gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; DataflowBlockOptions() { BoundedCapacity = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; });
    &lt;span class=&quot;hljs-keyword&quot;&gt;foreach&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; s &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; sources) s.LinkTo(resultBlock);

    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; resultBlock;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;どうでしょう？ &lt;code&gt;resultBlock&lt;/code&gt; は、1件はバッファに持ってしまうので、後段のブロックがどうであれ、ソースからは必ず1件多く取り出されてしまいます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;1件くらいいいじゃない？ それは &lt;code&gt;sources&lt;/code&gt; 次第でしょう。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;というわけで、本題のバッファのない PropagatorBlock が欲しい、ということです。もし &lt;code&gt;resultBlock&lt;/code&gt; にバッファがなければ、 &lt;code&gt;CreateSource&lt;/code&gt; の戻り値を利用する（リンクする）とき、初めて &lt;code&gt;sources&lt;/code&gt; からデータが取り出されます。やりたいですね。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_タイトルオチ&quot;&gt;タイトルオチ&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;もうタイトルでオチてますが、このような PropagatorBlock はデータフローブロックのプロトコル上、おそらく作れません。プロトコルについては&lt;a href=&quot;https://blog.azyobuzi.net/2020/04/30/01-reactivestreams/&quot;&gt;以前&lt;/a&gt;ざっくりと紹介しましたが、今回はこのプロトコルと、既存のブロックの実装で使われているロックが鍵となります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;TPL Dataflow のブロック間の通信は、完全に直列です。ある SourceBlock からは同時に1件しか送信しないし、ある TargetBlock は同時に1件しか受信できません。その制御は &lt;code&gt;lock&lt;/code&gt; ステートメントで行われています（絶対ボトルネックじゃん）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;PropagatorBlock は Source と Target 両方の性質を持っており、 Target で受信したデータを加工して Source がデータを出力します。 Target 部は1件ずつ受信を行い、加工を行うタスクへ投げ、加工が終わったデータは Source 部のキューに積まれ、 Source 部は1件ずつ送信を行います。つまり PropagatorBlock においては Target と Source は並列に動いています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;TPL Dataflow のソースコードを読むと、 TargetBlock または PropagatorBlock の Target 部を直列化するために使用されるロックを &lt;code&gt;IncomingLock&lt;/code&gt;、 SourceBlock または PropagatorBlock の Source 部を直列化するために使用されるロックを &lt;code&gt;OutgoingLock&lt;/code&gt; と呼んでいるので、この名称を使っていきます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;では、このロックを考慮しながら、 Source から Target へデータを送信する各パターンをシーケンス図に表してみます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;basicoffer.svg&quot; alt=&quot;Source から Target へデータを送信する様子&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;もう複数のロックがあるという時点で嫌ですね。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ではここで、間にバッファのない PropagatorBlock が入ったらどうなるでしょう？ 変わりませんね。通信内容をそのまま素通しすればいいだけなので。しかし忘れてはいけないことがあります: 間に入るブロックもブロックなので、ファンインもファンアウトも複数持つことができます。したがって、今注目していた Source と Target 以外の要因によって通信が発生することがあります。例えば、別の Target にデータを送信できたので、次の1件の送信を開始しよう、とすると次の操作が開始します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;offerbypropagator.svg&quot; alt=&quot;Propagator が送信を開始する様子&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;そろそろ嫌な予感がしてきましたね。 Propagator は Source の OutgoingLock なんてお構いなしに Target にデータの送信を試みることができます。つまり、タイミングによっては……。実際に例を見てみましょう。 Source が Propagator に送信しようとしたら、 Propagator が Target に送信中だった場合、こうなります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;deadlock1.svg&quot; alt=&quot;デッドロックが発生する例&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;見事なデッドロックですね。並行にロックを取得する場合、取得順を同じにしないとデッドロックするという鉄則がありますが、完全に破る構図です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ただ、このデッドロックは実は回避できます。「(1) OfferMessage」のところで Propagator が「(2) ConsumeMessage」を実行中でまだ返ってきてないぞと判断して、このメッセージを延期させてしまえば、 OutgoingLock が外れるので先に進むことができます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;今の例では、 Source, Propagator, Target が 1:1:1 だったので回避できました。が、1:N:1、つまりひとつの Source が複数の Propagator に接続されていて、さらにその Propagator たちがひとつの Target に接続されている場合はどうでしょう。先程の図の (1) が Propagator1 で、 (2) が Propagator2 で起こっていたら、 Propagator 同士はお互いを知らないので調停することができません。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_まとめ&quot;&gt;まとめ&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;バッファを持たない PropagatorBlock は、デッドロックを起こす運命にあります。回避可能なケースは Source, Propagator, Target が 1:1:1 の関係にあるときです。例えば、 &lt;a href=&quot;https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.dataflow.dataflowblock.linkto?view=net-5.0#System_Threading_Tasks_Dataflow_DataflowBlock_LinkTo__1_System_Threading_Tasks_Dataflow_ISourceBlock___0__System_Threading_Tasks_Dataflow_ITargetBlock___0__System_Predicate___0__&quot;&gt;&lt;code&gt;LinkTo&lt;/code&gt; メソッドの &lt;code&gt;predicate&lt;/code&gt; 引数を持つオーバーロード&lt;/a&gt;は、内部で PropagatorBlock を作成しています。しかしこのブロックは外部へ公開されず、あくまでリンクのために隠蔽されています。通常のブロックとして、複数のファンイン、ファンアウトを持てるという要件を満たそうとすると、不可能になります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;結局この記事で何が言いたかったかというと、拙作の TPL Dataflow 補助ライブラリの &lt;a href=&quot;https://github.com/azyobuzin/BiDaFlow&quot;&gt;BiDaFlow&lt;/a&gt; で、バッファなしの &lt;code&gt;TransformBlock&lt;/code&gt; を提供していたのですが、デッドロックの可能性を排除できなかったので、機能を削除することにしました。悲しい。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[画像可逆圧縮形式 FLIF についてのメモ]]></title><description><![CDATA[FLIF (Free Lossless Image Format) は、実用されている可逆圧縮形式としておそらく現在最強の圧縮手法です。実際、画像圧縮手法に関する最近の研究では、 FLIF が比較対象となることが多いように思われます。このブログ記事では、 FLIF がどのように圧縮を行っているのか、理解できた範囲で記録していきます。


ファイル形式としての特徴は、アルファチャンネル対応、 HDR (サブピクセルが8ビットより大きい) 対応、アニメーション対応と、現代的な画像形式として一般的な構成となっています。


圧縮手法としての特徴は、次の2点が挙げられます。




色空間 (YCoCg) や画素値の範囲を変換することで、画素間の相関が大きくなり、効率よく符号化できるようにします。


エントロピー符号化に使用する確率分布の使い分け（コンテキスト）を入力画像から決定木の形式で学習します。




FLIF は、すでに ImageMagick で実装されており、すぐに試すことができます。また、コーデックのリファレンス実装は GitHub にあります (FLIF-hub/FLIF)。


なお、現在 FLIF の開発はストップしており、 FLIF の成果は JPEG XL に取り込まれるようです。ただ JPEG XL の説明を読む限り、以上に挙げた特徴とは違っているので、手法としては別物になるのではないかと思っています。]]></description><link>https://blog.azyobuzi.net/2020/10/11/01-flif/</link><guid isPermaLink="false">https://blog.azyobuzi.net/2020/10/11/01-flif/</guid><pubDate>Sun, 11 Oct 2020 11:51:00 GMT</pubDate><content:encoded>&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://flif.info/&quot;&gt;FLIF (Free Lossless Image Format)&lt;/a&gt; は、実用されている可逆圧縮形式としておそらく現在最強の圧縮手法です。実際、画像圧縮手法に関する最近の研究では、 FLIF が比較対象となることが多いように思われます。このブログ記事では、 FLIF がどのように圧縮を行っているのか、理解できた範囲で記録していきます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ファイル形式としての特徴は、アルファチャンネル対応、 HDR (サブピクセルが8ビットより大きい) 対応、アニメーション対応と、現代的な画像形式として一般的な構成となっています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;圧縮手法としての特徴は、次の2点が挙げられます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;色空間 (YCoCg) や画素値の範囲を変換することで、画素間の相関が大きくなり、効率よく符号化できるようにします。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;エントロピー符号化に使用する確率分布の使い分け（コンテキスト）を入力画像から決定木の形式で学習します。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;FLIF は、すでに ImageMagick で実装されており、すぐに試すことができます。また、コーデックのリファレンス実装は GitHub にあります (&lt;a href=&quot;https://github.com/FLIF-hub/FLIF:&quot;&gt;FLIF-hub/FLIF&lt;/a&gt;)。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;なお、現在 FLIF の開発はストップしており、 FLIF の成果は JPEG XL に取り込まれるようです。ただ &lt;a href=&quot;https://gitlab.com/wg1/jpeg-xl/-/blob/bf10dc87f9b91cf2eb536b36362987a992b3c25f/doc/xl_overview.md#lossless:&quot;&gt;JPEG XL の説明&lt;/a&gt;を読む限り、以上に挙げた特徴とは違っているので、手法としては別物になるのではないかと思っています。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_他の可逆圧縮手法との比較&quot;&gt;1. 他の可逆圧縮手法との比較&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;（あんまり詳しくないので、ツッコミよろ）&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;現在 web でシェアを取っている PNG と WebP は、 Deflate のような辞書型圧縮が使用されています。 PNG や WebP の可逆圧縮モードでは、入力画像の画素値、または隣接画素を使った画素値の予測をしたときの誤差（残差）を Deflate のような手法で圧縮します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;FLIF は、このような辞書型圧縮 + ハフマン符号の構成ではなく、算術符号で符号化を行います。算術符号については後で説明します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;算術符号を使用する手法としては、 JPEG 2000 や H.264 があります。これらの手法では、2値に対する算術符号が使用されています。 FLIF もこれらの手法を参考にしつつ、算術符号化にもちいる確率分布を獲得する方法を工夫しています。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_flif_ファイルの構成&quot;&gt;2. FLIF ファイルの構成&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;FLIF ファイルは、大きく次のように構成されます。区切り方は &lt;a href=&quot;https://flif.info/spec.html:&quot;&gt;FLIF16 Specification&lt;/a&gt; に従っています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;dlist&quot;&gt;
&lt;dl&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;Main Header&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;画像の大きさやチャンネル数が記述されます。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;Metadata&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;任意のデータを書き込めます。ここに Exif とかを入れます。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;Second Header&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;圧縮に使用するパラメータが記述されます。ここで色空間やその他の変換をするのか、するならば変換に使用するパラメータを記述します。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;Pixel Data&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;Second Header で指定した変換がなされた画像のデータです。この記事で詳しく説明します。&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_画素値の符号化順&quot;&gt;3. 画素値の符号化順&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;画素値の符号化には2種類の方法が用意されています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;dlist&quot;&gt;
&lt;dl&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;非インターレース (Non-interlaced)&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;左上の画素から順番に符号化していきます。デフォルトでは、総画素数が1万未満のときに使用されます。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;インターレース (Interlaced)&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;画像を 1/2, 1/4, 1/8, …… と縮小していき、小さい画像から順に符号化していきます。画素値を予測するときに、小さい画像の画素値を使って予測を行うことができるので、非インターレースではできないような予測（予測しようとしている画素の右下の画素を使う）ができます。&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_非インターレース方式&quot;&gt;3.1. 非インターレース方式&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;非インターレース方式では、 Pixel Data パートは次のような構造になります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;MANIAC 符号化 (&lt;a href=&quot;#_meta_adaptive&quot;&gt;Section 4.4&lt;/a&gt;) に使用する決定木&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;チャンネルごとに、画素値を左上からラスタスキャンの順に MANIAC 符号化したデータ&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;実際に符号化する画素値は、予測された画素値との誤差になります。予測に使用する画素は、 &lt;a href=&quot;#img-px-noninterlace&quot;&gt;Figure 1&lt;/a&gt; に示すように、予測する画素 X の左上、上、左です。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;img-px-noninterlace&quot; class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;px_noninterlace.svg&quot; alt=&quot;非インターレース方式で参照する周辺画素&quot; height=&quot;75&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;title&quot;&gt;Figure 1. 非インターレース方式で参照する周辺画素&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;予測値は、 L+T-TL, L, T の中央値です。 X-予測値 が実際に符号化される値になります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;アルファチャンネルがある場合、アルファチャンネルが一番最初に符号化されます。なぜなら、 Second Header の項目に、透明ピクセルのデータを捨てる（Aが0ならRGBの値は未定義にする）オプションがあるため、ある座標が透明ピクセルかどうかがわからないと他のチャンネルを符号化・復号化できないからです。アルファチャンネル以外については、 YCoCg はその順番で、 RGB は Second Header の変換で PermutePlanes が指定されているかどうかで決まります。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_インターレース方式&quot;&gt;3.2. インターレース方式&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;大きいサイズの画像に対しては、非インターレース方式よりも複雑ですが、予測精度の高い手法を用いることで、圧縮効率を稼ぎます。インターレース方式では小さい画像から段々と大きい画像を復元していきます。 PNG だとインターレースを使用するメリットは読み込み途中でも画像を表示できるという程度ですが、 FLIF では圧縮率に貢献します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;次の表は実際の復号化中のデータを Y チャンネル（輝度値）について取り出したものです。この場合では、ズームレベル 14 から順番に復元していきます。&lt;/p&gt;
&lt;/div&gt;
&lt;table class=&quot;tableblock frame-all grid-all stretch&quot;&gt;
&lt;caption class=&quot;title&quot;&gt;Table 1. インターレース方式で画素が復元される様子&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 33.3333%;&quot;&gt;
&lt;col style=&quot;width: 33.3333%;&quot;&gt;
&lt;col style=&quot;width: 33.3334%;&quot;&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;ズームレベル&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;サイズ&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;画像&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;0&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;120×120 (原画像サイズ)&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;span class=&quot;image&quot;&gt;&lt;img src=&quot;interlace/dec_i01_fr00_z00_p00.png&quot; alt=&quot;ZL=0&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;1&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;120×60&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;span class=&quot;image&quot;&gt;&lt;img src=&quot;interlace/dec_i00_fr00_z01_p00.png&quot; alt=&quot;ZL=1&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;2&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;60×60&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;span class=&quot;image&quot;&gt;&lt;img src=&quot;interlace/dec_rough_i30_fr00_z02_p00.png&quot; alt=&quot;ZL=2&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;3&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;60×30&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;span class=&quot;image&quot;&gt;&lt;img src=&quot;interlace/dec_rough_i27_fr00_z03_p00.png&quot; alt=&quot;ZL=3&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;4&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;30×30&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;span class=&quot;image&quot;&gt;&lt;img src=&quot;interlace/dec_rough_i24_fr00_z04_p00.png&quot; alt=&quot;ZL=4&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;5&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;30×15&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;span class=&quot;image&quot;&gt;&lt;img src=&quot;interlace/dec_rough_i21_fr00_z05_p00.png&quot; alt=&quot;ZL=5&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;6&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;15×15&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;span class=&quot;image&quot;&gt;&lt;img src=&quot;interlace/dec_rough_i18_fr00_z06_p00.png&quot; alt=&quot;ZL=6&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;7&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;15×8&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;span class=&quot;image&quot;&gt;&lt;img src=&quot;interlace/dec_rough_i15_fr00_z07_p00.png&quot; alt=&quot;ZL=7&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;8&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;8×8&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;span class=&quot;image&quot;&gt;&lt;img src=&quot;interlace/dec_rough_i12_fr00_z08_p00.png&quot; alt=&quot;ZL=8&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;9&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;8×4&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;span class=&quot;image&quot;&gt;&lt;img src=&quot;interlace/dec_rough_i09_fr00_z09_p00.png&quot; alt=&quot;ZL=9&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;10&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;4×4&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;span class=&quot;image&quot;&gt;&lt;img src=&quot;interlace/dec_rough_i06_fr00_z10_p00.png&quot; alt=&quot;ZL=10&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;11&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;4×2&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;span class=&quot;image&quot;&gt;&lt;img src=&quot;interlace/dec_rough_i04_fr00_z11_p00.png&quot; alt=&quot;ZL=11&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;12&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;2×2&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;span class=&quot;image&quot;&gt;&lt;img src=&quot;interlace/dec_rough_i02_fr00_z12_p00.png&quot; alt=&quot;ZL=12&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;13&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;2×1&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;span class=&quot;image&quot;&gt;&lt;img src=&quot;interlace/dec_rough_i01_fr00_z13_p00.png&quot; alt=&quot;ZL=13&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;14&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;1×1&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;span class=&quot;image&quot;&gt;&lt;img src=&quot;interlace/dec_rough_i00_fr00_z14_p00.png&quot; alt=&quot;ZL=14&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;具体的なアルゴリズムを書くと長くなるので、以上のように画素が埋まっていくんだなと解釈してください（雑）。最後のズームレベルは 1×1 になるので、より大きな画像ではズームレベルがさらに多くなります。また、横長、縦長の画像では、あるズームレベルで 1 ピクセルも復元されないことがあります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;このように圧縮すると何がうれしいかというと、すでに復号化されている隣接画素の情報を画素値予測に使うことができることができます。図からも 4×4 くらいになれば、手がかりになりそうなデータになっていることが分かると思います。実際、インターレース方式で使用する予測器は、非インターレース方式の予測器よりもリッチです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;予測器はズームレベルが偶数か奇数かで少し挙動が変わります。なぜなら周囲の画素の復号化状況が異なるからです。偶数では行を復号化するため、下側の画素を参照することができますが、右側を参照することはできません。奇数では列を復号化するため、逆に右側を参照することできますが、下側を参照することができません。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;実際の予測器を見てみましょう。予測する画素 X の周辺画素に次のように名前を付けておきます。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;img-px-interlace&quot; class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;px_interlace.svg&quot; alt=&quot;インターレース方式で参照する周辺画素&quot; height=&quot;150&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;title&quot;&gt;Figure 2. インターレース方式で参照する周辺画素&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;次に示す図は、画素 X を復号化するときの、周辺画素の復号化状況です。背景がグレーになっている画素は前のズームレベルまでに復号化された画素、背景が白の画素は今のズームレベルで復号化する画素です。「?」となっている部分はまだ復号化されていません。この通り、ズームレベル偶数では R を参照することはできず、奇数では B を参照することができません。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;img-px-horizontal&quot; class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;px_horizontal.svg&quot; alt=&quot;偶数ズームレベルにおける周辺画素&quot; height=&quot;150&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;title&quot;&gt;Figure 3. 偶数ズームレベルにおける周辺画素&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;img-px-vertical&quot; class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;px_vertical.svg&quot; alt=&quot;奇数ズームレベルにおける周辺画素&quot; height=&quot;150&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;title&quot;&gt;Figure 4. 奇数ズームレベルにおける周辺画素&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;また、画像の端っこの画素を処理するときには、参照できない周辺画素があります。その場合は、偶数ズームレベルでは必ず T があり、奇数ズームレベルでは L があるので、その値を代用します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;予測器は次の3つから選ぶことができます。チャンネルごとに指定するかズームレベルごとに指定するかが選べます。リファレンス実装のデフォルトでは、チャンネルごとにズームレベル 0 と 1 で試しにすべての予測器で予測させて、誤差が一番少ないものを選択します。&lt;/p&gt;
&lt;/div&gt;
&lt;table class=&quot;tableblock frame-all grid-all stretch&quot;&gt;
&lt;caption class=&quot;title&quot;&gt;Table 2. インターレース方式における予測器&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 20%;&quot;&gt;
&lt;col style=&quot;width: 40%;&quot;&gt;
&lt;col style=&quot;width: 40%;&quot;&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;予測器&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;ズームレベル偶数&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;ズームレベル奇数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;0&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;div class=&quot;content&quot;&gt;&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;(T + B) &amp;gt;&amp;gt; 1&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;div class=&quot;content&quot;&gt;&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;(L + R) &amp;gt;&amp;gt; 1&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;1&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;div class=&quot;content&quot;&gt;&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;次の中央値&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;(T + B) &amp;gt;&amp;gt; 1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;L + T - TL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;L + B - BL&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;div class=&quot;content&quot;&gt;&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;次の中央値&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;(L + R) &amp;gt;&amp;gt; 1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;L + T - TL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;R + T - TR&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;2&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;div class=&quot;content&quot;&gt;&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;次の中央値&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;T&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;B&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;L&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;div class=&quot;content&quot;&gt;&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;次の中央値&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;T&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;L&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;R&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;「&amp;gt;&amp;gt; 1」は 2 で割って切り捨てなので、平均を求めていることになります。予測器 0 では両隣の平均、予測器 1 では斜め方向も含めて計算してみて中央値を取る、予測器 3 では周囲の中央値を取るという戦略になっています。予測器で使われない TT や LL といった画素は、 &lt;a href=&quot;#_meta_adaptive&quot;&gt;Section 4.4&lt;/a&gt; で説明する決定木の条件として参照されます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_符号化&quot;&gt;4. 符号化&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;それでは、予測値の誤差をどのようにビット表現に変換しているのかについて説明していきましょう。 FLIF ではこの符号化手法のことを MANIAC (Meta-Adaptive Near-zero Integer Arithmetic Coding) と呼んでいます。ここでは、算術符号 (Arithmetic Coding)、適応的算術符号 (Adaptive Arithmtic Coding)、 Near-zero Integer Coding、 Meta-Adaptive に分割して説明していきたいと思います。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_算術符号&quot;&gt;4.1. 算術符号&lt;/h3&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_実数による算術符号&quot;&gt;4.1.1. 実数による算術符号&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;算術符号は、記号の出現確率分布（累積分布）を表す数直線上で、符号化したい記号列がどの位置にあるのか、を記録する符号化方式です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;まずは簡単な概念の説明のために、0～1の実数で考えてみます。 FLIF で使用される算術符号では「0」と「1」の2種類の記号だけが登場する（二値算術符号）記号列を扱うので、ここでも2種類の記号で考えます。例えば、「0」が 40% 、「1」が 60% の確率で出現することがわかっているとします。この確率によって、 0～1 の数直線を分割すると、このようになります。数直線上に点を置いたとき 0～0.4 の範囲にあるならば 0、 0.4～1 ならば 1 を表している、と解釈できます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;ac_fig1.svg&quot; alt=&quot;算術符号を説明する数直線1&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;では、この分割を再帰的に用いて、記号列「101」を数直線上に表してみましょう。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;最初の記号は 1 なので、 0.4～1 の範囲に注目します。この範囲をさらに 40:60 に分割するとこのようになります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;ac_fig2.svg&quot; alt=&quot;算術符号を説明する数直線2&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;2個目の記号は 0 なので、次は 0.4～0.64 の範囲に注目し、同じように分割します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;ac_fig3.svg&quot; alt=&quot;算術符号を説明する数直線3&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;この結果から、記号列「101」をこの数直線上に表すと 0.496～0.64 の範囲となることがわかりました！ 符号化結果としては、範囲の左端を使って「0.496」とすることにしましょう。このように、記号列を記号の出現確率を使って数直線上に表す方法が、算術符号になります。復号化するときは、「0.496」がどの記号の範囲に含まれているかを、同じように分割しながら探索していきます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_range_coder&quot;&gt;4.1.2. Range Coder&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;先ほどの例では実数を使って表しましたが、記号列が長くなると相当な精度の小数を使用しなければ正しく符号化結果を記録できないことがわかると思います。また小数を使用すると計算速度も遅くなります。そこで、現実的な実装方法として、整数を使用する Range Coder という手法が用いられます。 FLIF のリファレンス実装のソースコードでは「RAC」と略されています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Range Coder では、正しく符号化結果を記録できるだけの長さ（整数）を持つ数直線上に、記号列をプロットします。とはいえ、その「十分な長さ」がどれだけ長くなるかわからないので、最初の数直線の長さを決めておき、注目範囲が閾値より小さくなったら、数直線の長さを拡張します。 FLIF では、最初の数直線の長さを 24 ビット、閾値を 16 ビットとしています。数直線の長さを拡張する際、そのとき注目している範囲の左端の上位ビット（ここでは差が 8 ビットなので 8 ビット分）を出力します。なぜなら、左端はこれ以上符号化を進めても、現在の右端を超えることはないため、上位ビットの値はほぼ決まっているからです（場合によっては桁上がりが発生して、上位ビットが変わることがあるため、少し工夫が必要です）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;詳細なアルゴリズムについては、私よりもうまい説明に任せたいと思います。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://fussy.web.fc2.com/algo/compress10_arithmetic.htm:&quot;&gt;圧縮アルゴリズム (10) 算術符号化&lt;/a&gt; (Fussy&amp;#8217;s HOMEPAGE)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://www.nct9.ne.jp/m_hiroi/light/pyalgo36.html:&quot;&gt;Algorithms with Python / レンジコーダ (range coder)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_コンテキスト&quot;&gt;4.1.3. コンテキスト&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;二値のエントロピー符号化全般として、圧縮率を良くするためには、出現確率が 0 と 1 のどちらかに極端に偏っているほうがうれしいです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;例えば、4ビットの整数を3個並べたビット列を、算術符号化することを考えてみます。 10, 11, 12 をそのままビット列にすると「1010 1011 1100」となり、 0 の出現確率は 0.417、 1 の出現確率は 0.583 となります。この確率分布で算術符号化しようとすると、出現確率が 0.5 に近く、圧縮する意味がほとんどないことがわかると思います。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;しかし、見方を変えると偏った分布に見えます。4ビット整数の最上位ビットだけをみると全部 1 です。さすがに 100% の確率で 1 が出現する、としてしまうと、もし 0 が出てしまったときに符号化不可能になってしまいますが、 1 の出現確率を大きくすることで、これらのビットを効率よく圧縮できます。つまり言いたいことは、ビット列をただそのままビット列として見るのではなく、ビットの持つ意味や符号化の状況（この例では整数の何ビット目か）ごとに確率分布を変えることで、圧縮率を改善できるということです。意味ごとの確率分布をコンテキストと呼びます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ただし FLIF ではコンテキストのコンテキストを考える必要があり、言葉が混乱するので、&lt;strong&gt;この後で「確率表 (chance table)」と「コンテキスト」に分割して再定義します&lt;/strong&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_適応的算術符号&quot;&gt;4.2. 適応的算術符号&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;先ほどの例では 0 と 1 の出現確率が分かっているという前提がありました。つまり符号化・復号化を行うには、事前に出現確率を仮定しておくか、出力に出現確率を記録するかをしなければいけません。しかし、雑に出現確率を仮定して符号化をすると、もし実際の記号列が仮定した出現確率と異なる分布だった場合、圧縮率は悪化してしまいます。そこで、出現確率を記録しておく必要はなく、雑な出現確率の仮定で、それなりに圧縮率を改善する方法として、符号化を行いながら確率を変化させる手法があります。実際の記号列に適応していくことから、適応的 (adaptive) と呼ばれます。コンテキストを使用する場合は、コンテキストごとに別々に適応させていくことができます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;FLIF で使用されている適応方法は非常に簡単なものです。初期の出現確率は仕様で指定されています。1ビットを符号化する（数直線を変化させる）たびに、出現確率を変化させます。変化量は、ビットが 0 ならば、 0 の出現確率を少し増やす（= 1 の出現確率を少し減らす）、 1 ならば 1 の出現確率を少し増やすというものです。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_near_zero_integer_coding&quot;&gt;4.3. Near-zero Integer Coding&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;FLIF では、各画素について、予測値からの誤差（整数）を記録します。予測が当たれば誤差は 0 に、当たらなくても大抵は近い値になるので誤差は 0 前後になるはずです。そこで、 0 に近いほどビット数が少なく済むような方法で、誤差を記録します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ビット列は、次のような構成になっています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;ゼロフラグ&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;正負符号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;仮数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;もし値がゼロなら、ゼロフラグを 1 としておしまいです。そうでなければ、正(1)か負(0)か、何ビットあるか、数値のビット列、の順で記録します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;例えば、「5」を符号化すると次のようになります。&lt;/p&gt;
&lt;/div&gt;
&lt;table id=&quot;tbl-nz51&quot; class=&quot;tableblock frame-all grid-all stretch&quot;&gt;
&lt;caption class=&quot;title&quot;&gt;Table 3. 「5」を Near-zero Integer Coding で符号化&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 12.5%;&quot;&gt;
&lt;col style=&quot;width: 12.5%;&quot;&gt;
&lt;col style=&quot;width: 12.5%;&quot;&gt;
&lt;col style=&quot;width: 12.5%;&quot;&gt;
&lt;col style=&quot;width: 12.5%;&quot;&gt;
&lt;col style=&quot;width: 12.5%;&quot;&gt;
&lt;col style=&quot;width: 12.5%;&quot;&gt;
&lt;col style=&quot;width: 12.5%;&quot;&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;ビット&lt;/p&gt;&lt;/th&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;0&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;1&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;0&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;0&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;1&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;0&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;1&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;ビット名&lt;/p&gt;&lt;/th&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;ZERO&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;SIGN&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;EXP(0, +)&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;EXP(1, +)&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;EXP(2, +)&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;MANT(1)&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;MANT(0)&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;指数部は数値が何ビットあるかを表します。数値が何ビットあるかは 0 が連続した数で決まります。この例では、 0 が 2 個続き、その次が 1 なので、 3 ビットの数値を表していることを表現しています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;仮数部は、最上位ビット以外の値がそのまま出力されます。最上位ビットについては、何ビットあるかが指数部で示されているので、 1 であることが確定しています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ただし、数値の取りうる範囲によっては、一部ビットが省略されることがあります。ここでは最小値を任意の負値、最大値を 5 として、 5 を符号化した例を見てみましょう。&lt;/p&gt;
&lt;/div&gt;
&lt;table id=&quot;tbl-nz52&quot; class=&quot;tableblock frame-all grid-all stretch&quot;&gt;
&lt;caption class=&quot;title&quot;&gt;Table 4. 「5」を最大値 5 の Near-zero Integer Coding で符号化&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 16.6666%;&quot;&gt;
&lt;col style=&quot;width: 16.6666%;&quot;&gt;
&lt;col style=&quot;width: 16.6666%;&quot;&gt;
&lt;col style=&quot;width: 16.6666%;&quot;&gt;
&lt;col style=&quot;width: 16.6666%;&quot;&gt;
&lt;col style=&quot;width: 16.667%;&quot;&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;ビット&lt;/p&gt;&lt;/th&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;0&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;1&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;0&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;0&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;1&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;ビット名&lt;/p&gt;&lt;/th&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;ZERO&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;SIGN&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;EXP(0, +)&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;EXP(1, +)&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-center valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;MANT(0)&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;まず、指数部の最後のビットが省略されました。なぜなら、最大値 5 は 3 ビットで表されるので 0 が 2 個続いた時点で、 3 ビットであることが確定するからです。次に仮数部の下位2ビット目が省略されました。なぜなら、 3 ビットで表す必要がある数値は 4 または 5 だけなので、下位 2 ビット目は必ず 0 になることが確定しているからです。このように実際に書き込まなくてもわかる場合は、ビットを省略する動作をします。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;#tbl-nz51&quot;&gt;Table 3&lt;/a&gt;、&lt;a href=&quot;#tbl-nz52&quot;&gt;Table 4&lt;/a&gt; には、ビット名という行を用意しました。これは &lt;a href=&quot;#_コンテキスト&quot;&gt;Section 4.1.3&lt;/a&gt; で説明したコンテキストが実際どのように使用されているのかを表しています。ビット名単位で適応が行われます。つまり予測器の出力が 0 になることが多ければ ZERO が 1 になる確率が適応によって段々と大きくなるし、正になることが多ければ SIGN が 1 になる確率が適応によって段々と大きくなるということです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ビット名は ZERO, SIGN, EXP(0～9, +), EXP(0～9, -), MANT(0～9) があります。 EXP は値が正か負かによって分かれます。これらそれぞれのビットの確率をまとめたものを、 FLIF では chance table と呼んでいます。ここでは便宜上日本語で「確率表」と呼ぶことにします。 Near-zero Integer は確率表を用いて適応的算術符号化を行うことができるということになります。ビット名に対応する初期確率は、仕様で定められています。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_meta_adaptive&quot;&gt;4.4. Meta-Adaptive&lt;/h3&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_ざっくりとした説明&quot;&gt;4.4.1. ざっくりとした説明&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ここまでで、各画素値を周囲の画素値を使って予測し、その予測誤差を確率表を使って適応的算術符号化して記録するということがわかりました。しかしまだ終わりではありません。 FLIF では確率表を状況に応じて使い分けます。つまり&lt;strong&gt;確率表のコンテキスト&lt;/strong&gt;を考えます。これが FLIF 用語での「コンテキスト」になります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;コンテキストについてざっくりいうと、符号化しようとしている画素に関する情報を条件とする決定木によって、使用する確率表が決定します（&lt;a href=&quot;#img-ctx-summary&quot;&gt;Figure 5&lt;/a&gt;）。条件には他のチャンネルの画素値や、周辺画素同士の差といった情報が使えます。条件に使用できる情報をそれぞれプロパティと呼び、非インターレース方式で10種類、インターレース方式で17種類のプロパティがあります。プロパティ値がある値より大きい場合と、ある値以下の場合で分岐します。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;img-ctx-summary&quot; class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;ctx_summary.svg&quot; alt=&quot;確率表のコンテキストを選択する決定木&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;title&quot;&gt;Figure 5. 確率表のコンテキストを選択する決定木&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_カウンター&quot;&gt;4.4.2. カウンター&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;さらに踏み込んで見てみます。もし最初から &lt;a href=&quot;#img-ctx-summary&quot;&gt;Figure 5&lt;/a&gt; のように使用する確率表が決まるとすると、それぞれの確率表の初期値はどのように決まるのでしょうか？ 確率表それぞれが別々に適応を行っていくので、すべての確率表を仕様で定められた確率で初期化したら、適応によって確率表が温まるまでの間に全画素についての処理が終わってしまいます。そこで FLIF の決定木にはカウンターという機能が盛り込まれています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;カウンターの説明のため、根と2つの葉だけの決定木を考えてみます。葉以外のノードは、条件とカウンターを持っています。この決定木を使って、画像を復号化することを例にカウンターの挙動を説明します。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;img-ctx-counter1&quot; class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;ctx_counter_1.svg&quot; alt=&quot;決定木の初期状態&quot; height=&quot;200&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;title&quot;&gt;Figure 6. 決定木の初期状態&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;この決定木を使って、画素をひとつ復号化してみましょう。まず決定木の根に注目します。するとカウンターの値は2です。注目したノードのカウンターが 0 より大きいとき、そのノードが持つ確率表を使って画素を復号化します。このとき、読み取ったビット列によって適応が行い、確率表1を更新します。そして、ノードのカウンターをデクリメントします。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;img-ctx-counter2&quot; class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;ctx_counter_2.svg&quot; alt=&quot;カウンターがデクリメントされる&quot; height=&quot;200&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;title&quot;&gt;Figure 7. カウンターがデクリメントされる&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;次の画素の復号化も同じように行います。すると根のカウンターが 0 になりました。もしノードのカウンターが 0 になったならば、そのノードの子ノードに確率表をコピーします。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;img-ctx-counter3&quot; class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;ctx_counter_3.svg&quot; alt=&quot;カウンターが0になると子に確率表がコピーされる&quot; height=&quot;200&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;title&quot;&gt;Figure 8. カウンターが0になると子に確率表がコピーされる&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;いま、確率表2と確率表3は、確率表1と同じ内容になっています。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;img-ctx-counter4&quot; class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;ctx_counter_4.svg&quot; alt=&quot;カウンターが0になると条件分岐が行われる&quot; height=&quot;200&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;title&quot;&gt;Figure 9. カウンターが0になると条件分岐が行われる&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;次の画素を復号化します。まず決定木の根に注目します。するとカウンターの値は 0 です。注目したノードのカウンターが 0 のとき、そのノードの条件を評価します。ここではプロパティAの値はX以下だったとします。決定木にしたがって分岐を行い、左側の子ノードに注目します。このノードは葉ノードなので、この確率表を使って復号化します。このとき適応によって確率表2が更新されます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;このように、カウンターが 0 になって初めて条件分岐が有効になります。つまり、確率表ひとつからスタートし、ある程度適応したら条件によって確率表を分岐させる、という作戦です。このことによって分岐したどの確率表も適応が進んだ状態になっており、効率的な符号化が行えます。この例では根の子が葉でしたが、実際にはもっと複雑な決定木が生成されます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_符号化時の学習&quot;&gt;4.4.3. 符号化時の学習&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;では、このような決定木をどのように獲得するのでしょうか。 FLIF エンコーダはまず決定木の学習のために何回か画像の符号化を試し、その後完成した決定木を使って最終的な符号化を行います。学習のためのお試し符号化は、デフォルトで2回行われます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;決定木の初期状態は1ノードのみ（根かつ葉）で、符号化中に段々と成長していきます。それでは、どのように決定木が成長するのか見てみましょう。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;葉ノードは次の情報を持っており、これらは1画素を符号化するたびに更新されます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;確率表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;何回このノードを使ったか &lt;code&gt;count&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;このノードを使った符号化で出力した情報量 &lt;code&gt;realSize&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;プロパティそれぞれについて&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;符号化するたびにプロパティ値を足していったもの &lt;code&gt;virtPropSum&lt;/code&gt; （&lt;code&gt;count&lt;/code&gt; で割れば平均になる）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;このプロパティの平均値を条件として分岐していたと仮定したときの確率表 &lt;code&gt;virtChances&lt;/code&gt; （平均値より大きい場合と、以下の場合のふたつ）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;このプロパティの平均値を条件として分岐していたと仮定したときの情報量の予測値 &lt;code&gt;virtSize&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;これらの更新処理を踏まえて、学習における1画素の符号化手順を次に示します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;根から決定木にしたがって葉ノードを探す。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;count&lt;/code&gt; をインクリメントする。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;すべてのプロパティ値を取得し、 &lt;code&gt;virtPropSum&lt;/code&gt; を更新する。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Near-zero Integer のそれぞれのビットを符号化する。&lt;/p&gt;
&lt;div class=&quot;olist loweralpha&quot;&gt;
&lt;ol class=&quot;loweralpha&quot; type=&quot;a&quot;&gt;
&lt;li&gt;
&lt;p&gt;ノードの確率表を使って符号化し、その情報量を &lt;code&gt;realSize&lt;/code&gt; に加算する。情報量とは算術符号化に使用した確率から求めた、確率が小さいほど大きくなる値のこと。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各プロパティについて、 &lt;code&gt;virtChances&lt;/code&gt; を使って符号化する。 &lt;code&gt;virtChances&lt;/code&gt; のふたつある確率表のうち、どちらの確率表を使うかは、現在のプロパティ値が &lt;code&gt;virtPropSum / count&lt;/code&gt; より大きいか、それ以下かで決まる。このときの情報量を &lt;code&gt;virtSize&lt;/code&gt; に加算する。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;そして、もしもっとも &lt;code&gt;virtSize&lt;/code&gt; が小さいプロパティについて &lt;code&gt;realSize - virtSize&lt;/code&gt; が閾値より大きくなったなら、そのプロパティを条件として分岐します。このときの &lt;code&gt;count&lt;/code&gt; が &lt;a href=&quot;#_カウンター&quot;&gt;Section 4.4.2&lt;/a&gt; で説明したカウンターになります（実際には決定木自体を符号化するときに効率が良くなるよう、実際の &lt;code&gt;count&lt;/code&gt; 値よりも少し簡単化します）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;このような操作を繰り返して、決定木が成長していきます。適応的符号化のコンテキストを決定木の形式でさらに適応させることから Meta-Adaptive というわけです。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_決定木の符号化&quot;&gt;4.4.4. 決定木の符号化&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;学習した決定木も FLIF ファイルに記録されます。決定木の各ノードについて、条件とするプロパティ番号、カウンター、条件とするプロパティ値が、行きがけ順で記録されます。各ノードについて3つの整数値を記録するので、3つの確率表が用意され、確率表を使って適応的算術符号化されます（Near-zero ではないものもありますが、 Near-zero Integer Coding を利用します）。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_インターレース方式の符号化&quot;&gt;4.5. インターレース方式の符号化&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;非インターレース方式では、すべての画素がこの決定木によって符号化・復号化されます。一方でインターレース方式では、最初から決定木を使うわけではなく、ズームレベルの小さい（数字の大きい）ほうから 12 個については確率表の慣らし運転をします。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;インターレース方式では、次の順番で符号化されます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;各チャンネルの左上1ピクセルを、定数の確率表を使って符号化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根ノードのみを持つ決定木を作成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最初の 12 ズームレベルを符号化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;残りのズームレベルで決定木の学習を行う&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;決定木を符号化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;残りのズームレベルを符号化&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;復号化は、これに合わせて次の順番で行われます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;各チャンネルの左上1ピクセルを、定数の確率表を使って復号化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根ノードのみを持つ決定木を作成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最初の 12 ズームレベルを復号化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;決定木を復号化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;残りのズームレベルを復号化&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_まとめ&quot;&gt;5. まとめ&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;FLIF は画像を次のように圧縮符号化しています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;色空間やパレットの変換（説明できるほど読み込んでいないので、この記事では紹介できませんでした）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;画素値を周辺画素から予測し、予測誤差を求める&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MANIAC という手法で予測誤差を符号化&lt;/p&gt;
&lt;div class=&quot;olist loweralpha&quot;&gt;
&lt;ol class=&quot;loweralpha&quot; type=&quot;a&quot;&gt;
&lt;li&gt;
&lt;p&gt;画像を試しに符号化してみて、予測誤差の傾向を決定木の形式で学習&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;決定木も出力ファイルに記録&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;この記事が、画像の可逆圧縮アルゴリズムを調べている方の助けになればと思います。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[プロトコルから比較する Reactive Streams と TPL Dataflow]]></title><description><![CDATA[以前、「いまさら使う TPL Dataflow」で紹介した TPL Dataflow は、入力されたデータを並列に処理するプログラムを、ブロックの組み合わせで簡単に記述できるライブラリです。
「類似品との比較」で述べたように、 TPL Dataflow は、プッシュ型とプル型の両方の性質を持っており、送信者（Producer）が、受信者（Consumer）が処理しきれないほど大量のデータをプッシュしようとするとき、受信者がそのデータの受信を遅延させることで、データフロー内を流れるデータ量を制御します。


一方で、このような、大量のデータや時系列データ（イベント列）を入力し、データフロー内を流れるデータ量を制御しながら、並列にデータを加工する仕組みは、一般的に、特に Java のコミュニティでは Reactive Streams と呼ばれています。 Reactive Streams に用いられるインターフェイスは Java 9 で java.util.concurrent.Flow として標準ライブラリ入りしており、 RxJava や Akka Streams がこのインターフェイスの実装を提供しています（実際には、互換性のため reactive-streams パッケージを通じて実装しています）。


C# においても Reactive Streams は他人事ではなく、 java.util.concurrent.Flow と同様のインターフェイスが Reactive.Streams パッケージとして NuGet で配布されており、標準的なインターフェイスの座を狙っています。また Akka.NET Streams がこのインターフェイスの実装を提供しています。


いずれの方法も、 Reactive Extensions (Rx) 的なプッシュ型に対して、流量制限（back pressure）を導入することで、データ量を制御しています。この記事では、 Reactive Streams と TPL Dataflow をプロトコル（インターフェイスとその実装方法）から比較します。]]></description><link>https://blog.azyobuzi.net/2020/04/30/01-reactivestreams/</link><guid isPermaLink="false">https://blog.azyobuzi.net/2020/04/30/01-reactivestreams/</guid><category><![CDATA[C#]]></category><pubDate>Wed, 29 Apr 2020 17:36:00 GMT</pubDate><content:encoded>&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;以前、&lt;a href=&quot;https://azyobuzin.hatenablog.com/entry/2019/05/26/164155&quot;&gt;「いまさら使う TPL Dataflow」&lt;/a&gt;で紹介した TPL Dataflow は、入力されたデータを並列に処理するプログラムを、ブロックの組み合わせで簡単に記述できるライブラリです。
&lt;a href=&quot;https://azyobuzin.hatenablog.com/entry/2019/05/26/164155#%E9%A1%9E%E4%BC%BC%E5%93%81%E3%81%A8%E3%81%AE%E6%AF%94%E8%BC%83&quot;&gt;「類似品との比較」&lt;/a&gt;で述べたように、 TPL Dataflow は、プッシュ型とプル型の両方の性質を持っており、送信者（&lt;em&gt;Producer&lt;/em&gt;）が、受信者（&lt;em&gt;Consumer&lt;/em&gt;）が処理しきれないほど大量のデータをプッシュしようとするとき、受信者がそのデータの受信を遅延させることで、データフロー内を流れるデータ量を制御します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一方で、このような、大量のデータや時系列データ（イベント列）を入力し、データフロー内を流れるデータ量を制御しながら、並列にデータを加工する仕組みは、一般的に、特に Java のコミュニティでは &lt;a href=&quot;https://www.reactive-streams.org/&quot;&gt;Reactive Streams&lt;/a&gt; と呼ばれています。 Reactive Streams に用いられるインターフェイスは Java 9 で &lt;code&gt;java.util.concurrent.Flow&lt;/code&gt; として標準ライブラリ入りしており、 RxJava や Akka Streams がこのインターフェイスの実装を提供しています（実際には、互換性のため &lt;a href=&quot;https://github.com/reactive-streams/reactive-streams-jvm&quot;&gt;reactive-streams パッケージ&lt;/a&gt;を通じて実装しています）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;C# においても Reactive Streams は他人事ではなく、 &lt;code&gt;java.util.concurrent.Flow&lt;/code&gt; と同様のインターフェイスが &lt;a href=&quot;https://github.com/reactive-streams/reactive-streams-dotnet&quot;&gt;Reactive.Streams パッケージ&lt;/a&gt;として NuGet で配布されており、標準的なインターフェイスの座を狙っています。また Akka.NET Streams がこのインターフェイスの実装を提供しています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;いずれの方法も、 Reactive Extensions (Rx) 的なプッシュ型に対して、流量制限（back pressure）を導入することで、データ量を制御しています。この記事では、 Reactive Streams と TPL Dataflow をプロトコル（インターフェイスとその実装方法）から比較します。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_reactive_streams&quot;&gt;1. Reactive Streams&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;先に Reactive Streams のほうから導入していきましょう。 Reactive Streams の基本思想は、&lt;strong&gt;受信者がどれだけデータを受け入れられるかを送信者に申告する&lt;/strong&gt;ことによって、流量の合意を取ります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;インターフェイスを見ていきましょう。 Reactive Streams では、送信者は &lt;em&gt;Publisher&lt;/em&gt;、受信者は &lt;em&gt;Subscriber&lt;/em&gt; と呼ばれます。 Publisher は Rx における Observable に対応し、 Subscriber は Observer に対応します。インターフェイスは次のようになっており、 &lt;code&gt;IPublisher.Subscribe&lt;/code&gt; に、購読者のコールバックを表す &lt;code&gt;ISubscriber&lt;/code&gt; インスタンスを渡すことによって、購読を開始します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;&lt;a href=&quot;https://github.com/reactive-streams/reactive-streams-dotnet/blob/v1.0.2/src/api/Reactive.Streams/IPublisher.cs&quot;&gt;IPublisher&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;cs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;IPublisher&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;
{
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Subscribe&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;ISubscriber&amp;lt;T&amp;gt; subscriber&lt;/span&gt;)&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;&lt;a href=&quot;https://github.com/reactive-streams/reactive-streams-dotnet/blob/v1.0.2/src/api/Reactive.Streams/ISubscriber.cs&quot;&gt;ISubscriber&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;cs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ISubscriber&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;
{
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;OnSubscribe&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;ISubscription subscription&lt;/span&gt;)&lt;/span&gt;;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;OnNext&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;T element&lt;/span&gt;)&lt;/span&gt;;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;OnError&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;Exception cause&lt;/span&gt;)&lt;/span&gt;;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;OnComplete&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;ISubscriber&lt;/code&gt; について、 Publisher がデータを送信するために &lt;code&gt;OnNext&lt;/code&gt; が呼び出され、 Publisher が送信すべきすべてのデータを送信しきったら &lt;code&gt;OnComplete&lt;/code&gt; が呼び出されます。また Publisher でエラーが発生したら &lt;code&gt;OnError&lt;/code&gt; が呼び出されます。 &lt;code&gt;OnComplete&lt;/code&gt; または &lt;code&gt;OnError&lt;/code&gt; が呼び出されたあとは、いずれのメソッドも呼び出されることはありません。このあたりのルールは Observer とまったく同じになっています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;IObservable&lt;/code&gt;、&lt;code&gt;IObserver&lt;/code&gt; と比較して、 &lt;code&gt;Subscribe&lt;/code&gt; の戻り値が &lt;code&gt;IDisposable&lt;/code&gt; ではなく &lt;code&gt;void&lt;/code&gt; ですが、これは &lt;a href=&quot;http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/ObservableSource.html#subscribe-io.reactivex.rxjava3.core.Observer-&quot;&gt;RxJava にあわせた&lt;/a&gt;ためだと思われます。購読の解除には、 &lt;code&gt;ISubscriber.OnSubscribe&lt;/code&gt; で受け取ることができる &lt;code&gt;ISubscription&lt;/code&gt; を使います。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Observable と異なり、 Subscribe を呼び出した瞬間にデータが飛んでくる（&lt;code&gt;ISubscriber.OnNext&lt;/code&gt; が呼び出される）ことはありません。 Publisher は Subscriber がどれだけのデータを受け取る準備があるかを確認してから、データを送信します。 Subscriber は、今どれだけのデータを受け取ることができるかを &lt;code&gt;OnSubscribe&lt;/code&gt; で受け取った &lt;code&gt;ISubscription&lt;/code&gt; インスタンスを通じて Publisher に申告します。 &lt;code&gt;ISubscription&lt;/code&gt; は次のように定義されています。 &lt;code&gt;Request&lt;/code&gt; メソッドに渡す引数が、どれだけデータを受信できるかを表します。 &lt;code&gt;Cancel&lt;/code&gt; は先ほど説明した &lt;code&gt;IDisposable&lt;/code&gt; の代わりとなるものです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;&lt;a href=&quot;https://github.com/reactive-streams/reactive-streams-dotnet/blob/v1.0.2/src/api/Reactive.Streams/ISubscription.cs&quot;&gt;ISubscription&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;cs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ISubscription&lt;/span&gt;
{
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Request&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;long&lt;/span&gt; n&lt;/span&gt;)&lt;/span&gt;;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Cancel&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Reactive Streams は以上のインターフェイスとルールによって成り立っています。キーポイントは &lt;strong&gt;Subscriber が Publisher に自分のキャパシティを伝え、 Publisher はそのキャパシティの範囲内で &lt;code&gt;OnNext&lt;/code&gt; を呼び出す&lt;/strong&gt;ことによって、データを送信を行っているところです。流量についてプル型でありながら、データを送信するタイミングは自由（プッシュ型）というところでしょうか。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Reactive Streams には、 Rx と同様に、 &lt;strong&gt;Hot な Publisher と Cold な Publisher があります&lt;/strong&gt;。 Hot と Cold の違いについては&lt;a href=&quot;https://blog.xin9le.net/entry/2012/01/18/105003&quot;&gt;「Rx入門 (13) - HotとCold - xin9le.net」&lt;/a&gt;が参考になります。ただし、 Reactive Streams では、 Rx と異なり流量制限があります。したがって、 Hot な Publisher や、時系列データを扱う Publisher が Subscriber に対してデータを送信しようとしたとき、キャパシティが足りない Subscriber がいる可能性があります。そのときに、どのような動作をするかは、実装次第です。例えば RxJava において Observable から Publisher に変換するときは、あふれた値を破棄したり、例外を送出したり、などの選択肢が与えられています（参考: &lt;a href=&quot;http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Observable.html#toFlowable-io.reactivex.rxjava3.core.BackpressureStrategy-&quot;&gt;Observable#toFlowable&lt;/a&gt;）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;最後に、シーケンス図で例を示しておきます。 2 件のデータを出力する Publisher と、データを 1 件ずつ処理することができる Subscriber を接続すると、次のように通信を行います。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/a/azyobuzin/20200429/20200429204015.png&quot; alt=&quot;Reactive Streams のシーケンス図&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;実際には、 Cold な Publisher を実装するときには、 &lt;code&gt;IPublisher&lt;/code&gt; は &lt;code&gt;ISubscription&lt;/code&gt; を作成するだけの存在となり、 &lt;code&gt;ISubscription&lt;/code&gt; が実際に Subscriber と通信するような実装になります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/a/azyobuzin/20200429/20200429230100.png&quot; alt=&quot;Cold な Publisher のシーケンス図&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_tpl_dataflow&quot;&gt;2. TPL Dataflow&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Reactive Streams は流量についてプル型とまとめましたが、 TPL Dataflow では逆の設計思想となっています。 TPL Dataflow では、&lt;strong&gt;データをプッシュしてみて、失敗したらプルされるのを待つ&lt;/strong&gt;、という戦略を取ることによって、流量制限を実現しています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;登場人物の紹介です。 TPL Dataflow では、送信者は &lt;em&gt;Source&lt;/em&gt;、受信者は &lt;em&gt;Target&lt;/em&gt; と呼ばれます。どちらもデータフローを構成する要素で、これら構成要素のことを&lt;em&gt;データフローブロック&lt;/em&gt;と呼びます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;まず、データフローブロック共通のインターフェイスである &lt;code&gt;IDataflowBlock&lt;/code&gt; を導入します。 &lt;code&gt;Completion&lt;/code&gt; はそのブロックがすべてのデータの処理が完了したら完了する（またはエラーとなる） &lt;code&gt;Task&lt;/code&gt; を表します。 &lt;code&gt;Complete&lt;/code&gt; と &lt;code&gt;Fault&lt;/code&gt; は Reactive Streams の &lt;code&gt;ISubscriber.OnComplete&lt;/code&gt;、&lt;code&gt;OnError&lt;/code&gt; に対応するものですが、 Target 以外もこのメソッドを実装します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.dataflow.idataflowblock?view=netcore-3.1&quot;&gt;IDataflowBlock&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;cs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;IDataflowBlock&lt;/span&gt;
{
    Task Completion { &lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;; }
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Complete&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Fault&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;Exception exception&lt;/span&gt;)&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Source から Target への接続は、リンクと呼ばれます。リンクによって、 Source は Target を認知し、もし送信できるデータがあるならば、データを送信します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;まずは Source のインターフェイスを見てみます。ユーザーが &lt;code&gt;LinkTo&lt;/code&gt; を呼び出すことによって、 Source から Target へのリンクが作成されます。戻り値の &lt;code&gt;IDisposable&lt;/code&gt; を使って、リンクを解除できます。その他のメソッドは Target によって呼び出されます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.dataflow.isourceblock-1?view=netcore-3.1&quot;&gt;ISourceBlock&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;cs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ISourceBlock&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TOutput&lt;/span&gt;&amp;gt; : &lt;span class=&quot;hljs-title&quot;&gt;IDataflowBlock&lt;/span&gt;
{
    &lt;span class=&quot;hljs-function&quot;&gt;IDisposable &lt;span class=&quot;hljs-title&quot;&gt;LinkTo&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;ITargetBlock&amp;lt;TOutput&amp;gt; target, DataflowLinkOptions linkOptions&lt;/span&gt;)&lt;/span&gt;;
    &lt;span class=&quot;hljs-function&quot;&gt;TOutput &lt;span class=&quot;hljs-title&quot;&gt;ConsumeMessage&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;DataflowMessageHeader messageHeader, ITargetBlock&amp;lt;TOutput&amp;gt; target, &lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;bool&lt;/span&gt; messageConsumed&lt;/span&gt;)&lt;/span&gt;;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ReserveMessage&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;DataflowMessageHeader messageHeader, ITargetBlock&amp;lt;TOutput&amp;gt; target&lt;/span&gt;)&lt;/span&gt;;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ReleaseReservation&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;DataflowMessageHeader messageHeader, ITargetBlock&amp;lt;TOutput&amp;gt; target&lt;/span&gt;)&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;対して、 Target のインターフェイスは、データを受信するための &lt;code&gt;OfferMessage&lt;/code&gt; と、 Source の完了を受け取る &lt;code&gt;IDataflowBlock.Complete&lt;/code&gt;、&lt;code&gt;Fault&lt;/code&gt; になります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.dataflow.itargetblock-1?view=netcore-3.1&quot;&gt;ITargetBlock&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;cs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ITargetBlock&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TInput&lt;/span&gt;&amp;gt; : &lt;span class=&quot;hljs-title&quot;&gt;IDataflowBlock&lt;/span&gt;
{
    &lt;span class=&quot;hljs-function&quot;&gt;DataflowMessageStatus &lt;span class=&quot;hljs-title&quot;&gt;OfferMessage&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;DataflowMessageHeader messageHeader, TInput messageValue, ISourceBlock&amp;lt;TInput&amp;gt;? source, &lt;span class=&quot;hljs-built_in&quot;&gt;bool&lt;/span&gt; consumeToAccept&lt;/span&gt;)&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;さて、 &lt;code&gt;LinkTo&lt;/code&gt; と &lt;code&gt;OfferMessage&lt;/code&gt; だけで成り立つならば話は簡単だったのですが、流量制限を導入するために、 Source と Target は密接に通信する必要があります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;まず、いくつかのメソッドの引数に現れた &lt;a href=&quot;https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.dataflow.dataflowmessageheader?view=netcore-3.1&quot;&gt;&lt;code&gt;DataflowMessageHeader&lt;/code&gt;&lt;/a&gt; について説明します。中身は &lt;code&gt;long&lt;/code&gt; 型の数値です。 Source が送信するメッセージには、 Source 内でユニークな（通常連番の） ID が振られます。この ID を用いて、どのメッセージについての呼び出しなのかを判定します（実際には、送信しようとしている最新のメッセージについてかどうかのアサーションを行うために用いられます）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;次に、 &lt;code&gt;OfferMessage&lt;/code&gt; がどのように振る舞うかです。もし、 Target に空きがあり、データを受信することができるならば、 &lt;code&gt;DataflowMessageStatus.Accepted&lt;/code&gt; を返して終わりです（ただし &lt;code&gt;consumeToAccept&lt;/code&gt; 引数が &lt;code&gt;true&lt;/code&gt; ならば、 Source の &lt;code&gt;ConsumeMessage&lt;/code&gt; を呼び出す必要があります）。一方で、 Target に空きがなく、データを受信することができないとき、 &lt;code&gt;DataflowMessageStatus.Postponed&lt;/code&gt; を返します。このとき Target は、受信できなかったメッセージの ID をキューに記録します。その後、空きができて受信できるようになったら、キューから ID を取り出し、 &lt;code&gt;ConsumeMessage&lt;/code&gt; を呼び出すことによって、 Source からデータを受信します。ただし、 Source は複数のリンク先を持つことができ、 Target が &lt;code&gt;Postponed&lt;/code&gt; を返したとき、他の Target へ送信しようとします。したがって、 &lt;code&gt;ConsumeMessage&lt;/code&gt; を呼び出しても、データを取得できないことがあります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;OfferMessage&lt;/code&gt; は同一 ID のメッセージについて、複数回呼び出されることを許容する必要があります。これは Source のリンクが変更されたときに、再度送信を試みるためです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;ReserveMessage&lt;/code&gt;、&lt;code&gt;ReleaseReservation&lt;/code&gt; については、最短一致モード（non-greedy mode）を実装するときと、 Source より先に Target が終了するときに Source にリンク解除を要求するために利用されます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ここまでだらだらと文章で説明してきましたが、&lt;strong&gt;アホほど面倒くさい&lt;/strong&gt;インターフェイスだということがわかったと思います。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;最後に、 Reactive Streams と同じように、 2 件のデータを出力する Source と、データを 1 件ずつ処理することができる Target のシーケンス図を示します。ここでは、 &lt;code&gt;LinkTo&lt;/code&gt; のオプションとして、完了を通知する &lt;code&gt;&lt;a href=&quot;https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.dataflow.dataflowlinkoptions.propagatecompletion?view=netcore-3.1&quot;&gt;PropagateCompletion&lt;/a&gt; = true&lt;/code&gt; を指定したものとします。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/a/azyobuzin/20200429/20200429224922.png&quot; alt=&quot;TPL Dataflow のシーケンス図&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_動作開始タイミングの違いについて&quot;&gt;3. 動作開始タイミングの違いについて&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;TPL Dataflow では、データフローブロック間のリンクが作成された時点で、 Source の準備ができていれば、データが送信されます。次の図は、 Source が送信したデータが Propagator（Target と Source の両方の性質を持つブロック）を経由して Target に到達するフローに対して、前から順にリンクを行ったときの動作の様子です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/a/azyobuzin/20200429/20200429232247.gif&quot; alt=&quot;TPL Dataflow が動作を開始する様子&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一方で、 Reactive Streams では、上の図のような使い方もできますが、通常はフローを作成し、それに対して Subscribe を呼び出すことで実際の処理を開始する、という使い方のほうが一般的かと思います。例えば、次の RxJava の例では、 &lt;a href=&quot;http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Flowable.html#range-int-int-&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; という Publisher と、それを加工する &lt;code&gt;map&lt;/code&gt; を接続したストリーム &lt;code&gt;flowable&lt;/code&gt;（&lt;code&gt;Publisher&amp;lt;Integer&amp;gt;&lt;/code&gt; を実装しています）を定義していますが、 &lt;code&gt;subscribe&lt;/code&gt; を呼び出すまでは、何も処理を行いません。また、 &lt;code&gt;range&lt;/code&gt; は Cold なストリームなので、複数回 &lt;code&gt;subscribe&lt;/code&gt; すると、そのたびに値が送信されます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; flowable = Flowable.range(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;).map(x -&amp;gt; x + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
flowable.blockingForEach(System.out::println); &lt;span class=&quot;hljs-comment&quot;&gt;// 2&lt;/span&gt;
flowable.blockingForEach(System.out::println); &lt;span class=&quot;hljs-comment&quot;&gt;// 2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;逆に TPL Dataflow で Cold なストリームを実現するには、フローの作成を関数で包むという方法が必要になります。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_並列化について&quot;&gt;4. 並列化について&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Reactive Streams プロトコルでは、 &lt;code&gt;OnNext&lt;/code&gt; を並行に呼び出すことを禁止されています。また TPL Dataflow も &lt;code&gt;OfferMessage&lt;/code&gt; を並行に呼び出すことはできません（これを間違えて、デッドロックを起こした経験が……）。したがって、いずれのプロトコルも、ひとつの Publisher の境界を越えて並列化することはできません。そこで、それぞれの実装から、どのように処理の並列化を行っているかを見ていきましょう。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Reactive Streams の実装である RxJava では、並列部分については &lt;code&gt;Publisher&lt;/code&gt; を実装しない独自の &lt;a href=&quot;http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/parallel/ParallelFlowable.html&quot;&gt;&lt;code&gt;ParallelFlowable&lt;/code&gt;&lt;/a&gt; 型で表されます。並列処理を終え、また直列なフローに戻るときに &lt;code&gt;Flowable&lt;/code&gt;（&lt;code&gt;Publisher&lt;/code&gt; の実装）で包み直します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; flowable = Flowable.range(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;) &lt;span class=&quot;hljs-comment&quot;&gt;// Flowable&lt;/span&gt;
    .parallel() &lt;span class=&quot;hljs-comment&quot;&gt;//  ParallelFlowable&lt;/span&gt;
    .runOn(Schedulers.computation())
    .map(x -&amp;gt; x + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)
    .sequential() &lt;span class=&quot;hljs-comment&quot;&gt;// Flowable&lt;/span&gt;
    .map(x -&amp;gt; x + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;TPL Dataflow では、各データフローブロックが並列に処理を行います。例えば、 &lt;code&gt;map&lt;/code&gt; に相当する &lt;a href=&quot;https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.dataflow.transformblock-2?view=netcore-3.1&quot;&gt;&lt;code&gt;TransformBlock&lt;/code&gt;&lt;/a&gt; や、基本的な Target である &lt;a href=&quot;https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.dataflow.actionblock-1?view=netcore-3.1&quot;&gt;&lt;code&gt;ActionBlock&lt;/code&gt;&lt;/a&gt; はオプションとして &lt;a href=&quot;https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.dataflow.executiondataflowblockoptions.maxdegreeofparallelism?view=netcore-3.1&quot;&gt;&lt;code&gt;MaxDegreeOfParallelism&lt;/code&gt;&lt;/a&gt; を指定することで、データが並列に処理されます。また RxJava では、並列部分ではデータの順番が維持される保証がありませんが、 &lt;code&gt;TransformBlock&lt;/code&gt; では &lt;code&gt;&lt;a href=&quot;https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.dataflow.dataflowblockoptions.ensureordered?view=netcore-3.1&quot;&gt;EnsureOrdered&lt;/a&gt; = true&lt;/code&gt; を指定することで、データの順番を維持できます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;いずれも実装の違いであり、インターフェイス上はどうにでもできます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_それぞれのメリットデメリット&quot;&gt;5. それぞれのメリット、デメリット&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_プロトコル&quot;&gt;5.1. プロトコル&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Reactive Streams のプロトコルには、一度 &lt;code&gt;Request&lt;/code&gt; した数を取り消せないという問題があります。したがって、状況によって受け入れられるデータ量が増減するようなとき、もっとも保守的な手法、すなわち 1 件受け取っては &lt;code&gt;Request(1)&lt;/code&gt; を呼び出すという非効率的な方法を取らざるを得なくなります。しかし、これが問題かというと、問題になるユースケースが特に思いつかないです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一方 TPL Dataflow は、独自でデータフローブロックを実装するのが非常に難しいです。標準で提供されているブロックの組み合わせだけでなんとかしてくださいという感じです。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_実装&quot;&gt;5.2. 実装&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Reactive Streams は、 Java では RxJava という最強の実装がありますが、 C# には Akka.NET Streams しかない状況です。 Akka.NET Streams は Akka のランタイムを必要とする重厚なものになっており、 RxJava ほど軽い気持ちで導入しにくいという印象があります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;TPL Dataflow は、半標準ライブラリな存在であり、品質も良いです。ただし、提供されているブロックは、有用ではありますが、もしかすると痒いところに手が届かないかもしれないなという品揃えです。ですが、先ほど述べたように、独自でデータフローブロックを実装するのはとても大変です（ある程度妥協できるなら、 &lt;a href=&quot;https://docs.microsoft.com/ja-jp/dotnet/api/system.threading.tasks.dataflow.dataflowblock.encapsulate?view=netcore-3.1&quot;&gt;&lt;code&gt;DataflowBlock.Encapsulate&lt;/code&gt;&lt;/a&gt; という便利メソッドがあることは覚えておいてください）。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_c_で_reactive_streams_とどう向き合うか&quot;&gt;6. C# で Reactive Streams とどう向き合うか&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Rx と並んで登場した Ix (Interactive Extensions) には AsyncEnumerable が含まれていました。 .NET Standard 2.1 では &lt;a href=&quot;https://docs.microsoft.com/ja-jp/dotnet/api/system.collections.generic.iasyncenumerable-1?view=netcore-3.1&quot;&gt;&lt;code&gt;IAsyncEnumerable&lt;/code&gt;&lt;/a&gt; が標準入りを果たしました。 AsyncEnumerable は、常に &lt;code&gt;Request(1)&lt;/code&gt; を投げる Reactive Streams と見なすこともできます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ここまで Reactive Streams と TPL Dataflow の比較をしてきましたが、&lt;strong&gt;AsyncEnumerable が C# における Reactive Streams の大本命&lt;/strong&gt;なのでは、と考えています（正確にはこの章を書き始めて気づいた……）。「並列化について」で述べたように、 Reactive Streams はいくら上流にキャパシティを報告したところで、 &lt;code&gt;OnNext&lt;/code&gt; を並行実行できません。したがって、キャパシティを報告することにあまり意味はなく、 AsyncEnumerable のように常にプル型でも問題ないと考えられます。キャパシティを気にする必要がある、流量の制御できないデータソースからの入力や、ある程度まとまったデータがないとパフォーマンスメリットがない並列化部分の前後にバッファを置くだけで解決できてしまいます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一方で、並列処理という観点では TPL Dataflow は非常に良質なライブラリです。並列処理において困る部分が隠蔽されており、本質的な処理を書くことに集中できます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;現在の私の野心としては、 AsyncEnumerable のメソッドチェーンの中に、 TPL Dataflow を導入することと、 &lt;code&gt;IAsyncEnumerable&lt;/code&gt; と &lt;code&gt;IPublisher&lt;/code&gt; の相互変換です。前者によって、 AsyncEnumerable を並列に処理する表現力が向上します。後者は Akka.NET Streams のような Java 由来のライブラリで Reactive Streams の利用が考えられることから、相互変換が容易に行えると便利だという考えです。これらは現在開発中のライブラリ（&lt;a href=&quot;https://github.com/azyobuzin/BiDaFlow&quot;&gt;BiDaFlow&lt;/a&gt;）で実現できればなと考えています。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_おわりに&quot;&gt;7. おわりに&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;（Reactive Streams と TPL Dataflow を比較しようと思って書き始めたはずだったのに、最終的に AsyncEnumerable 最強という結論になってしまって :thinking_face:）&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[諦めのポエム]]></title><description><![CDATA[冬。国内学会の総合大会の季節。間に合わん！]]></description><link>https://blog.azyobuzi.net/2020/12/02/01-akirame/</link><guid isPermaLink="false">https://blog.azyobuzi.net/2020/12/02/01-akirame/</guid><category><![CDATA[日記]]></category><pubDate>Tue, 01 Dec 2020 18:52:00 GMT</pubDate><content:encoded>&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;冬。国内学会の総合大会の季節。間に合わん！&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_自己紹介&quot;&gt;自己紹介&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;自己紹介。情報工学系修士1年。研究テーマは&lt;a href=&quot;https://blog.azyobuzi.net/2020/10/11/01-flif/&quot;&gt;前回の投稿&lt;/a&gt;みたいな話をやっていきたいというところです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;そしてあまりにも進捗が爆発してしまったので、ここに反省文を書こうという気持ちです。こんなもの書いてる暇があったら研究計画を立てろ。すいません。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;研究テーマは学部の卒論から変更して、心機一転2年間持たせられるネタをということで、今のテーマに落ち着きました。私の所属する研究室は、ほとんどがひとり1プロジェクトかつ放置系なので、自分で分野を探して自分で勝手に始めていく必要があります。もともとは DBMS でも作ろうと思って入った研究室でしたが、新規性のある提案を何ひとつ思いつかず、学部も修士も全然違う分野をやっています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;私の弱みは「新規性のある提案を何ひとつ思いつかず」がすべてを物語っています。現状に満足しがちで、課題感がない。その上、知識の幅の狭さ、社会経験の少なさで、社会課題へのアンテナもありません。そんな中からひねり出せるアイデアは、レッドオーシャンで性能バトルをするくらいになってしまいがちです。現在の研究テーマはなんとかレッドオーシャンを回避しているような気がしますが、結局課題解決というより性能バトルな感じになってしまっています。本当は、もっと具体的な課題を用意して、それに絞った研究をすることで、成果を出しやすくするべきなのでしょうが……。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_何もしてないのに多忙&quot;&gt;「何もしてないのに多忙」&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;研究が進みません。研究しなくてはいけないという気持ちがあります。だから忙しいなぁと思います。で、今日どれだけ進んだっけ？ 進捗ゼロですね。みたいなことをもう数ヶ月続けています。1ヶ月に1回まわってくる進捗発表の直前1週間だけ馬鹿力が出ます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;そんな逃げ方をしていたら、もう冬でした。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;プレッシャーの原因は、ほとんど自分自身によるものです。可処分時間を研究に使っていたらこれくらいできるだろうという高い期待がありました。今までの成功体験がありました。奨学生として相応な成果を出さなければという気持ちもありました。プレッシャーが高まると、基本的には馬鹿力が出ます。しかし、本当に間に合いそうにないときは、ただただ無力になり、苦しい気持ちだけが残ります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;たぶんこれが、初めての失敗体験になります。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_あこがれ&quot;&gt;あこがれ&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;なんであんなに時間を、1日をうまく使えるんでしょうかね。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;パワフルな人は、朝起きて、作業をして、朝食を食べて、作業をします。&lt;a href=&quot;https://amzn.to/33yJf6R&quot;&gt;「なぜ、あなたの仕事は終わらないのか」&lt;/a&gt;なんかがいい例です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;それに比べて私は……、と思うものです。授業開始ギリギリまで寝て、授業を受けて、終わったら寝て、カクヨムを読んで、やっとPCに向かってSNSを眺めて、最後に作業に手を付けるのは深夜、みたいな生活をしています。たまにまともな生活をすることもありますが、作業に集中するあまり深夜になっていて、翌日からは逆戻りです。結局、集中できてしまったときに制御できなくなり、その反動で悪化する、を繰り返しており、規則的な生活でコンスタントな成果を出し続けることができません。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_コロナが悪かったのか&quot;&gt;コロナが悪かったのか？&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;コロナのせいにしたいが、もしコロナが流行ってなかったとしても、成果が出ていた自信は……ないかな。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ただ、学部の頃の進捗は、「ついで研究室」に頼っていたのは事実です。授業を受けるために大学に行き、授業後は閉館時間まで研究室に居る。そうして、研究を進めるか雑談をするか以外にできない環境に身を置き続けることで、自分で自分を制御しなくても、研究が進む環境がありました。そして、院生生活もそのように進めていく予定でした。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;しかし現状はリモート授業になってしまいました。すると先にも挙げたように、授業が終わったらすぐサボれる環境が出来上がっています。その結果、研究について考え、作業を進める時間は大幅に減ったように感じます。時間を区切ったり、週報を書いたりする試みもしましたが、これも「集中できてしまったときに制御できなくなり、その反動で悪化する」のパターンに陥ってしまいました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;講義なんてオンラインでも何でもいいんですけれども、「ついで研究室」ができないことが院生にとっては非常に問題だと感じました。給料も出ないのに、自宅で自分を制御することは難しい。皆さんがどのくらい同じ苦しみを感じているかはわかりませんが、私には難しすぎました。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_おわりに&quot;&gt;おわりに&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;自己管理能力のなさがコロナで炙り出されてしまった、と言えばいいのでしょうか。今までの人生であまり失敗を経験せず、ぬるま湯の中で過ごして来てしまったので、今この状況で、まさに苦しいという感情になっています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;今できることは、目標を下げに下げまくり、それに自分と教授を納得させることかなと思います。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;口ではプライドなんてないよみたいなことを言ってきた記憶がありますが、それはプライドが邪魔をするほどの失敗をしたことがなかっただけのような気がします。高すぎる自分への期待を、適切に制御する方法が、今後必要なのでしょうけれど、今はまだその技術を手に入れる方法がわかりません。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Visual Studio と VSCode どちらでも使える Docker Compose 環境]]></title><description><![CDATA[開発環境を Docker でいい感じにしてくれるやつとして、 Visual Studio では「コンテナー開発ツール」が、 Visual Studio Code には Remote 拡張があります。これらは Dockerfile や docker-compose.yml を用意すると、その中でアプリを動かすことができるやつです。しかし、同じものではないので、挙動はまったく異なります。それぞれメリット、デメリットがあるので、両方使えるとうれしいわけです。そこで、うまいこと両方で使える docker-compose.yml を書いてみようという試みをやっていきます。]]></description><link>https://blog.azyobuzi.net/2020/09/28/01-vs-docker-compose/</link><guid isPermaLink="false">https://blog.azyobuzi.net/2020/09/28/01-vs-docker-compose/</guid><category><![CDATA[C#]]></category><category><![CDATA[Docker]]></category><pubDate>Sun, 27 Sep 2020 17:29:00 GMT</pubDate><content:encoded>&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;開発環境を Docker でいい感じにしてくれるやつとして、 Visual Studio では「コンテナー開発ツール」が、 Visual Studio Code には Remote 拡張があります。これらは Dockerfile や docker-compose.yml を用意すると、その中でアプリを動かすことができるやつです。しかし、同じものではないので、挙動はまったく異なります。それぞれメリット、デメリットがあるので、両方使えるとうれしいわけです。そこで、うまいこと両方で使える docker-compose.yml を書いてみようという試みをやっていきます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_それぞれのメリットデメリット&quot;&gt;それぞれのメリット、デメリット&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;コンテナ化、特に Docker Compose を使いたい理由として、クラサバ型データベースを開発環境に置きたいという欲求があります。適当にデバッグ実行したら適当なデータベースが動いていると便利です。というわけで、今回は PostgreSQL コンテナとアプリ開発環境が共存することを目標とします。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Visual Studio の Docker 連携は、コンテナにビルド結果とデバッガーの口をマウントして、コンテナ内でアプリを実行してくれます。メリットは、開発環境はホストにあるので、 Visual Studio をフルに使えることです。デメリットは、コンテナ内に入って何か操作するというのが面倒なところです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;VSCode Remote は、コンテナの中で VSCode が動きます。ホストのディレクトリをコンテナにマウントすることで、ホストのファイルを編集できます。メリットは、 VSCode のターミナルからコンテナ内を触り放題なところです。例えば Windows で開発していて、 Linux で動かしたい開発ツールがあるときには便利です。デメリットは、 Visual Studio に慣れた人間にとって、 VSCode の C# 拡張は不足を感じるところです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;データベースを置くという今回の仮定では、データベースを手で操作するときに簡単に環境に入るために VSCode を使いたいものの、メインの開発は Visual Studio でしたい、となり、共存させたい欲求が発生しています。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_やっていく&quot;&gt;やっていく&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_1_visual_studio_で連携を設定する&quot;&gt;1. Visual Studio で連携を設定する&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ここで説明する手順を実行するには、 Visual Studio 2019 で「ASP.NET と Web 開発」または「.NET Core クロスプラットフォームの開発」ワークロードがインストールされている必要があります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ソリューションエクスプローラーで、 Docker で動かしたいプロジェクトを右クリックし、「コンテナー オーケストレーターのサポート」を追加します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/a/azyobuzin/20200928/20200928004102.png&quot; alt=&quot;「コンテナー オーケストレーターのサポート」を追加&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;いろいろ聞かれますが、 OS は Linux、ツールは Docker Compose としておけば OK です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;完了すると、 Dockerfile と「docker-compose」というプロジェクトが生えます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/a/azyobuzin/20200928/20200928004106.png&quot; alt=&quot;完了後のソリューション&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;これで、必要なファイルを Visual Studio に自動生成させることができました。ここから先は生成されたファイル書き換えたり移動させたりして VSCode にフィットさせていきましょう。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_2_dockerfile_を改変する&quot;&gt;2. Dockerfile を改変する&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;生成された Dockerfile を確認すると、本番ビルド用のスクリプトが書かれています。今回はこれを完全に捨てることにします。ただ、プロジェクトディレクトリ下に Dockerfile がないと Visual Studio が認識してくれないので、ここに開発環境を作成するスクリプトを書きましょう。本番用 Dockerfile はどこか別のところに置いてください……。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;最低限必要なのは &lt;code&gt;FROM mcr.microsoft.com/dotnet/core/sdk:3.1-buster&lt;/code&gt; だけです。「buster」のところは好きなディストリビューションに変えてください。必要に応じて、例えば今回の仮定ならば postgresql-client を入れたりするのもいいでしょう。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_3_docker_compose_yml_を改変する&quot;&gt;3. docker-compose.yml を改変する&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ここからの操作は Visual Studio を破壊するので、すべてが完了するまで Visual Studio は閉じておきましょう。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;いま、ソリューションディレクトリ直下に「docker-compose.yml」と「docker-compose.override.yml」があります。直下にあってもわかりにくいので、後で devcontainer.json というファイルを入れることになる .devcontainer というディレクトリをつくっておき、そこに移動させます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/a/azyobuzin/20200928/20200928010233.png&quot; alt=&quot;docker-compose.yml を .devcontainer へ移動&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;さらに、 docker-compose.override.yml という名前だと Visual Studio 用なのか VSCode 用なのかわかりにくいので、 docker-compose.vs.yml に改名しておくといいでしょう。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;いま docker-compose.yml の中身はこのようになっていると思います。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;docker-compose.yml&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;version:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;3.4&amp;#x27;&lt;/span&gt;

&lt;span class=&quot;hljs-attr&quot;&gt;services:&lt;/span&gt;
  &lt;span class=&quot;hljs-attr&quot;&gt;mydatabaseapp:&lt;/span&gt;
    &lt;span class=&quot;hljs-attr&quot;&gt;image:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;${DOCKER_REGISTRY-}mydatabaseapp&lt;/span&gt;
    &lt;span class=&quot;hljs-attr&quot;&gt;build:&lt;/span&gt;
      &lt;span class=&quot;hljs-attr&quot;&gt;context:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;.&lt;/span&gt;
      &lt;span class=&quot;hljs-attr&quot;&gt;dockerfile:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;MyDatabaseApp/Dockerfile&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;改変が必要なポイントは次のふたつです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;build.context&lt;/code&gt; のパスを正しく直す。 docker-compose.yml を移動したので、それに合わせます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PostgreSQL を追加する。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;改変結果はこんな感じです。 docker-compose.yml の構文バージョンやプロジェクト名は、環境に合わせて書き換えてください。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;docker-compose.yml&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;version:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;3.4&amp;#x27;&lt;/span&gt;

&lt;span class=&quot;hljs-attr&quot;&gt;services:&lt;/span&gt;
  &lt;span class=&quot;hljs-attr&quot;&gt;mydatabaseapp:&lt;/span&gt;
    &lt;span class=&quot;hljs-attr&quot;&gt;build:&lt;/span&gt;
      &lt;span class=&quot;hljs-attr&quot;&gt;context:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;..&lt;/span&gt;
      &lt;span class=&quot;hljs-attr&quot;&gt;dockerfile:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;MyDatabaseApp/Dockerfile&lt;/span&gt;

  &lt;span class=&quot;hljs-attr&quot;&gt;db:&lt;/span&gt;
    &lt;span class=&quot;hljs-attr&quot;&gt;image:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;postgres:11&lt;/span&gt;
    &lt;span class=&quot;hljs-attr&quot;&gt;environment:&lt;/span&gt;
      &lt;span class=&quot;hljs-attr&quot;&gt;POSTGRES_PASSWORD:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;postgres&lt;/span&gt;
    &lt;span class=&quot;hljs-attr&quot;&gt;volumes:&lt;/span&gt;
      &lt;span class=&quot;hljs-bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;./db/data:/var/lib/postgresql/data&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;データベースのデータの永続化は、ホストのパスを指定するか、この docker-compose.yml の外で作成したボリュームを割り当ててください。でないと、 VS と VSCode で Docker Compose のプロジェクト名が異なるので、同じデータを見てくれません。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_4_docker_compose_dcproj_を改変する&quot;&gt;4. docker-compose.dcproj を改変する&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;docker-compose.yml を移動したので、こっちも書き換えます。これもソリューションディレクトリ直下にあると邪魔なので .devcontainer に移動させてしまいましょう。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;さらにファイル名変更を反映して、ディレクトリ外に行ってしまった .dockerignore をプロジェクトから消します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;docker-compose.dcproj&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;diff&quot;&gt; &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
 &amp;lt;Project ToolsVersion=&amp;quot;15.0&amp;quot; Sdk=&amp;quot;Microsoft.Docker.Sdk&amp;quot;&amp;gt;
   &amp;lt;PropertyGroup Label=&amp;quot;Globals&amp;quot;&amp;gt;
     &amp;lt;ProjectVersion&amp;gt;2.1&amp;lt;/ProjectVersion&amp;gt;
     &amp;lt;DockerTargetOS&amp;gt;Linux&amp;lt;/DockerTargetOS&amp;gt;
     &amp;lt;ProjectGuid&amp;gt;3caba81b-3f76-4ecf-9907-78b96280d41c&amp;lt;/ProjectGuid&amp;gt;
   &amp;lt;/PropertyGroup&amp;gt;
   &amp;lt;ItemGroup&amp;gt;
&lt;span class=&quot;hljs-deletion&quot;&gt;-    &amp;lt;None Include=&amp;quot;docker-compose.override.yml&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-addition&quot;&gt;+    &amp;lt;None Include=&amp;quot;docker-compose.vs.yml&amp;quot;&amp;gt;&lt;/span&gt;
       &amp;lt;DependentUpon&amp;gt;docker-compose.yml&amp;lt;/DependentUpon&amp;gt;
     &amp;lt;/None&amp;gt;
     &amp;lt;None Include=&amp;quot;docker-compose.yml&amp;quot; /&amp;gt;
&lt;span class=&quot;hljs-deletion&quot;&gt;-    &amp;lt;None Include=&amp;quot;.dockerignore&amp;quot; /&amp;gt;&lt;/span&gt;
   &amp;lt;/ItemGroup&amp;gt;
 &amp;lt;/Project&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;またソリューションファイルもパスを書き換えます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;MyDatabaseApp.sln&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;diff&quot;&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;-Project(&amp;quot;{E53339B2-1760-4266-BCC7-CA923CBCF16C}&amp;quot;) = &amp;quot;docker-compose&amp;quot;, &amp;quot;docker-compose.dcproj&amp;quot;, &amp;quot;{3CABA81B-3F76-4ECF-9907-78B96280D41C}&amp;quot;&lt;/span&gt;
&lt;span class=&quot;hljs-addition&quot;&gt;+Project(&amp;quot;{E53339B2-1760-4266-BCC7-CA923CBCF16C}&amp;quot;) = &amp;quot;docker-compose&amp;quot;, &amp;quot;.devcontainer\docker-compose.dcproj&amp;quot;, &amp;quot;{3CABA81B-3F76-4ECF-9907-78B96280D41C}&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_5_vscode_向けの_docker_compose_yml_をつくる&quot;&gt;5. VSCode 向けの docker-compose.yml をつくる&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;VSCode 向けに .devcontainer/docker-compose.vscode.yml を作っていきます。ポイントは次のふたつです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;コンテナが終了しないように無限ループさせる&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作業ディレクトリをマウントする&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;実際の YAML で表すとこれだけです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;docker-compose.vscode.yml&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;version:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;3.4&amp;#x27;&lt;/span&gt;

&lt;span class=&quot;hljs-attr&quot;&gt;services:&lt;/span&gt;
  &lt;span class=&quot;hljs-attr&quot;&gt;mydatabaseapp:&lt;/span&gt;
    &lt;span class=&quot;hljs-attr&quot;&gt;command:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;/bin/sh&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;while sleep 1000; do :; done&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;hljs-attr&quot;&gt;volumes:&lt;/span&gt;
      &lt;span class=&quot;hljs-bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;..:/workspace:cached&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;必要に応じて、ポートを公開するために &lt;code&gt;ports&lt;/code&gt; を追加したりしてください。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;参考: &lt;a href=&quot;https://bufferings.hatenablog.com/entry/2020/06/11/233201&quot;&gt;VS Code Remote - Containers を Docker Compose で使うのだー！ - Mitsuyuki.Shiiba&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_6_devcontainer_json_をつくる&quot;&gt;6. devcontainer.json をつくる&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;devcontainer.json は VSCode にコンテナ作成を指示する設定ファイルです。これも .devcontainer に置きます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;最小限の devcontainer.json はこんな感じです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;devcontainer.json&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;json&quot;&gt;{
  &lt;span class=&quot;hljs-attr&quot;&gt;&amp;quot;dockerComposeFile&amp;quot;&lt;/span&gt;: [
    &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;docker-compose.yml&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;docker-compose.vscode.yml&amp;quot;&lt;/span&gt;
  ],

  &lt;span class=&quot;hljs-comment&quot;&gt;// docker-compose.yml の services のうち、開発環境につかうもの&lt;/span&gt;
  &lt;span class=&quot;hljs-attr&quot;&gt;&amp;quot;service&amp;quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;mydatabaseapp&amp;quot;&lt;/span&gt;,

  &lt;span class=&quot;hljs-comment&quot;&gt;// docker-compose.vscode.yml で指定したマウント先&lt;/span&gt;
  &lt;span class=&quot;hljs-attr&quot;&gt;&amp;quot;workspaceFolder&amp;quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;/workspace&amp;quot;&lt;/span&gt;,

  &lt;span class=&quot;hljs-comment&quot;&gt;// 事前にインストールしておいてほしい拡張&lt;/span&gt;
  &lt;span class=&quot;hljs-attr&quot;&gt;&amp;quot;extensions&amp;quot;&lt;/span&gt;: [
    &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;ms-dotnettools.csharp&amp;quot;&lt;/span&gt;
  ]
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;いじり倒したいときは &lt;a href=&quot;https://code.visualstudio.com/docs/remote/devcontainerjson-reference&quot;&gt;devcontainer.json reference&lt;/a&gt; を読むといいでしょう。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_完成&quot;&gt;完成！&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;これで準備完了です。 VSCode で「Reopen in Container」を実行すると、コンテナ上で VSCode が動き始めます。 Dockerfile のビルドが走るので気長に待ちましょう。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;また、 Visual Studio でも docker-compose プロジェクトをスタートアッププロジェクトに設定して実行できるはずです！&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock caution&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;div class=&quot;title&quot;&gt;Caution&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
Visual Studio と VSCode の同時実行は危険です。同じマウント先のデータベースがふたつ動くことになってしまいます。また、それぞれ終了後 30 秒くらいはコンテナが動いているので、コンテナが終了されたことを確認してから、他方を使ってください。
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_まとめ&quot;&gt;まとめ&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;頑張れば Visual Studio でも VSCode でも使える Docker Compose 環境がつくれることを示しました。これで開発が捗ればいいね。捗らんか……。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ここまでの内容を clone するだけでお試しできるものを GitHub に置いておきました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/azyobuzin/vs-docker-compose-example&quot;&gt;azyobuzin/vs-docker-compose-example&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[結局、理想のネットワークは Docker で実現できなかった]]></title><description><![CDATA[Cilium の Docker プラグインの導入を検討したものの、無理みがあった。ぱたり。]]></description><link>https://blog.azyobuzi.net/2020/09/14/01-cilium/</link><guid isPermaLink="false">https://blog.azyobuzi.net/2020/09/14/01-cilium/</guid><category><![CDATA[Docker]]></category><pubDate>Mon, 14 Sep 2020 13:13:00 GMT</pubDate><content:encoded>&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://cilium.io/&quot;&gt;Cilium&lt;/a&gt; の Docker プラグインの導入を検討したものの、無理みがあった。ぱたり。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_イントロダクション&quot;&gt;イントロダクション&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ケチケチしたインターネットライフに Kubernetes は無縁です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;以前、 Docker のネットワークに細かい設定ができないという不満があって、 Kubernetes の調査をしていたこともありました[1]。しかしながら、趣味で動かしている web サーバに Kubernetes を導入するのは、ケチケチした人間には不可能です。メモリ 2GB (GMO の株主優待を受けて、スペックアップしました！) の VPS に詰め込めるだけのアプリを詰める、そういうことをしている人間にとっては、 Kubernetes の導入はデメリットの方が多くなります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;そんなわけで、私が管理しているサービスは、基本的に Docker Compose で管理されています。しかし、動かしているアプリも増えてきて、 Pleroma のような SSRF 対策[2]も必要なアプリも出てくると、そろそろ真面目にネットワークポリシーを導入して、安心してコンテナを動かしたくなります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://azyobuzin.hatenablog.com/entry/2019/03/21/024504&quot;&gt;Kubernetesで隔離Mastodonネットワークを作った&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://azyobuzin.hatenablog.com/entry/2019/11/12/005317&quot;&gt;比較的安全に Docker で Pleroma サーバーを建てる&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;しかしまぁどう検索しても Kubernetes の話しか出てこなくてキレそうだったわけですが、 &lt;a href=&quot;https://cilium.io/&quot;&gt;Cilium&lt;/a&gt; という仮想ネットワークツールが Docker のプラグインとして動いてくれるみたいなので、検証してみました。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_docker_ネットワークの課題&quot;&gt;Docker ネットワークの課題&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Docker 標準の bridge ネットワークの表現力を確認して、課題を確認します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;まず、 Docker のネットワークとは何かですが、隔離されたサブネットです。コンテナはネットワークに接続することで、そのサブネットの IP アドレスが与えられます。 &lt;code&gt;docker network connect&lt;/code&gt; コマンドで接続できるので「接続」と書きましたが、「参加」という表現のほうがわかりやすいかもしれません。コンテナは 0 個以上のネットワークに参加することができます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/a/azyobuzin/20200913/20200913020748.png&quot; alt=&quot;コンテナとネットワークの関係&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;基本的なネットワークの種類である bridge ネットワークでは、ネットワークごとに次のような設定ができます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;ネットワーク内のコンテナ間で通信 (Inter Container Connectivity) できるようにするか&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IP マスカレードを有効にするか = ホストの外に通信できるようにするか&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;これの何が不満かというと、コンテナ間の通信の可否はネットワーク単位でしか設定できないということです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;例えば、次の図のように、ふたつのアプリがひとつのデータベースを共有しているとします。前提がケチケチなので、アプリごとにデータベースのプロセスを分けたりしないという想定です。これを bridge ネットワークで実現しようとすると、DB、アプリ1、アプリ2が同一ネットワークに参加している必要があります。すると、アプリとデータベースの通信だけできればいいにも関わらず、アプリ同士の通信も可能になっています。これがまずい状況であるという例を示しましょう。アプリ1がクリティカルな情報を扱っているものの、認証は前段のリバースプロキシに任せている、とします。ここでアプリ2に脆弱性があったら、意図せずアプリ1のデータを認証なしで読み出してしまうかもしれません。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/a/azyobuzin/20200913/20200913022141.png&quot; alt=&quot;DBを参照するふたつのアプリ&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;このような想定をし始めると、 bridge ネットワークに不満を感じてくるでしょう。コンテナ間の通信を制御しているのは iptables なので、 iptables を直接いじってあげればどうにかできなくはないですが、自分でやりたくはないです。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_cilium&quot;&gt;Cilium&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;とりあえず「docker network policy」でググってみてください。はい、 1 ページ目のすべてが Kubernetes ですね。というわけで、意外と Docker のネットワークを強固にしようという試みはやられていないようです。存在するネットワークプラグインは皆複数ノードをひとつのネットワークとして使えるようにするみたいなやつばかりです。そんな中で、やっと見つけてきたのが Cilium です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Cilium も複数ノードをひとつのネットワークとして使えるようにするやつのひとつです。メインの用途は Kubernetes の仮想ネットワークです。 Kubernetes の仮想ネットワークといえば、クラスタ内がひとつのネットワークになっていて、初期状態では任意の Pod 同士で通信ができるやつです。そして、それを制限する方法として NetworkPolicy リソースがあります。 Cilium はこれを実現します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Cilium が他の仮想ネットワークツールと違うところは、 Kubernetes がなくてもネットワークポリシーが設定できるところです。つまり単体で使い物になる！ ……はずでした。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_getting_started&quot;&gt;Getting Started&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Cilium を Docker で使う例は、ドキュメントにこの 1 ページしかありません。ありがとうございました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.cilium.io/en/v1.8/gettingstarted/docker/&quot;&gt;Cilium with Docker &amp;amp; libnetwork ― Cilium 1.8.3 documentation&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Debian 10 で試してみましたが、特に Linux の設定は必要なく、&lt;a href=&quot;https://github.com/cilium/cilium/blob/v1.8.3/examples/getting-started/docker-compose.yml&quot;&gt;サンプルの docker-compose.yml&lt;/a&gt; を投入するだけで起動することができました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;とにかく、この 1 ページを一通り読むと、ポリシー設定を突っ込むところまで体験できます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;メモリ使用量は Cilium + Consul で 100MB 弱と、まぁまぁ許容範囲内かなというところでした。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_で何がダメだったの&quot;&gt;で、何がダメだったの？&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;ポートバインディング (&lt;code&gt;--publish&lt;/code&gt;) が使えない&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ポリシーが永続化されない&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_1_ポートバインディングが使えない&quot;&gt;1. ポートバインディングが使えない&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;docker run -p 80:80 nginx&lt;/code&gt; と書くとホストの 80 番ポートからコンテナの 80 番ポートにつながるやつです。 Cilium の Docker プラグインはこのオプションを実装していないので、指定しても何も起こりません。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;改造して解決しようかと挑んだものの、別の課題を先になんとかしないといけないことがわかったので面倒になりました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;これは現実的な解決策があり、 Traefik を使ったリバースプロキシを host ネットワークに用意すればいいです。 Traefik 2 からは TCP のリバースプロキシもできるようになったので、 HTTP に限らず何でもいけます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_2_ポリシーが永続化されない&quot;&gt;2. ポリシーが永続化されない&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;これが致命的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ポリシーを設定しても永続化してくれません。 Consul や etcd がそこにあるのにどうして記憶してくれないの？&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;永続化されないということは Cilium が起動したときにポリシーを設定する必要があります。これが問題になるのは、特にマシンや Docker デーモンを再起動したときです。 Cilium が起動するのを待ち、ポリシーを設定するようなサイドカーを用意しておかないと、正しくポリシーが適用されません。このようなサイドカーの実装を考え始めると、どんどん制御ループ、つまり Kubernetes のコンセプトに近づいていきます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_結局&quot;&gt;結局&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://azyobuzin.hatenablog.com/entry/2019/03/04/144245&quot;&gt;K3s に最初に食いついた&lt;/a&gt;人間なので、諦めて K3s と仲良くするのが一番いいのかもしれません。うっ……。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;働かざる者Kubeからずというように、個人の趣味プロジェクトでKubernetesを使うべきではない&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; &lt;a href=&quot;https://twitter.com/azyobuzin/status/1251774353579978758&quot;&gt;@azyobuzin&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_おまけ_ipv6_を使う&quot;&gt;おまけ: IPv6 を使う&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.cilium.io/en/v1.8/gettingstarted/docker/&quot;&gt;サンプル&lt;/a&gt;をいくらか改造すると IPv6 も使えるようになります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;Vagrantfile の &lt;code&gt;cilium_opts&lt;/code&gt; から &lt;code&gt;--enable-ipv6=false&lt;/code&gt; を削除する&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cilium-net&lt;/code&gt; を作成するコマンドで &lt;code&gt;--ipv6&lt;/code&gt; を指定する&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code&gt;docker network create --driver cilium --ipam-driver cilium --ipv6 cilium-net&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;これでコンテナに IPv6 アドレスが振られるようになります。が、 NAT が設定されないので外に出ていったパケットが帰ってこられなくなります。これは Cilium の Issue に積まれていますが、なかなか修正される様子がないです。ワークアラウンドとしては、自分で ip6tables を設定してねということです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Install an ip6tables MASQUERADE rule for IPv6 traffic leaving the node.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code&gt;ip6tables -t nat -A POSTROUTING ! -o cilium_+ -s f00d::/16 -j MASQUERADE&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; &lt;a href=&quot;https://github.com/cilium/cilium/issues/6320#issuecomment-442722329&quot;&gt;Cilium needs ip6tables rules to route IPv6 packets · Issue #6320 · cilium/cilium&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[ProjectReference にバージョン範囲を指定したい]]></title><description><![CDATA[複数のプロジェクトをひとつのリポジトリで管理するとき、プロジェクト間の参照関係は csproj に &lt;ProjectReference&gt; を書くわけですが、ここで、このプロジェクトを NuGet パッケージ化するときのことを考えます。例えば、 A と B というプロジェクトがあり、 B が A に依存しているとします。このとき B を dotnet pack してできあがるパッケージの A への依存はどのようになるでしょうか？ 実際にやってみると、現在の A のバージョン以上という依存関係になります。


ここで、 A の現在のバージョンを 1.0.0 とします。 Semantic Versioning に従っていると考えると、もし 2.0.0 がリリースされたら、破壊的な変更が入っているかもしれません。それでも B から A への依存は 1.0.0 以上で良いのでしょうか？ と考えると、「以上」以外の柔軟な依存関係を指定したくなりませんか？ というわけで、 &lt;ProjectReference&gt; を使ったプロジェクト間参照で、柔軟なバージョン範囲指定をしたいというのが今回のお話です。]]></description><link>https://blog.azyobuzi.net/2020/05/03/01-projectref/</link><guid isPermaLink="false">https://blog.azyobuzi.net/2020/05/03/01-projectref/</guid><category><![CDATA[C#]]></category><pubDate>Sat, 02 May 2020 19:07:00 GMT</pubDate><content:encoded>&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;複数のプロジェクトをひとつのリポジトリで管理するとき、プロジェクト間の参照関係は csproj に &lt;code&gt;&amp;lt;ProjectReference&amp;gt;&lt;/code&gt; を書くわけですが、ここで、このプロジェクトを NuGet パッケージ化するときのことを考えます。例えば、 A と B というプロジェクトがあり、 B が A に依存しているとします。このとき B を &lt;code&gt;dotnet pack&lt;/code&gt; してできあがるパッケージの A への依存はどのようになるでしょうか？ 実際にやってみると、現在の A のバージョン&lt;strong&gt;以上&lt;/strong&gt;という依存関係になります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ここで、 A の現在のバージョンを 1.0.0 とします。 Semantic Versioning に従っていると考えると、もし 2.0.0 がリリースされたら、破壊的な変更が入っているかもしれません。それでも B から A への依存は 1.0.0 &lt;strong&gt;以上&lt;/strong&gt;で良いのでしょうか？ と考えると、「以上」以外の柔軟な依存関係を指定したくなりませんか？ というわけで、 &lt;code&gt;&amp;lt;ProjectReference&amp;gt;&lt;/code&gt; を使ったプロジェクト間参照で、柔軟なバージョン範囲指定をしたいというのが今回のお話です。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_サンプルプロジェクト&quot;&gt;サンプルプロジェクト&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;文章でだらだらと説明されても読みたくないのはわかります。ので、実際の csproj を示しておきます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;A/A.csproj&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;Project&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;Sdk&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Microsoft.NET.Sdk&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;PropertyGroup&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;TargetFramework&lt;/span&gt;&amp;gt;&lt;/span&gt;netstandard2.0&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;TargetFramework&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;Version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.0.0&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;Version&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;PropertyGroup&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;Project&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;B/B.csproj&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;Project&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;Sdk&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Microsoft.NET.Sdk&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;PropertyGroup&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;TargetFramework&lt;/span&gt;&amp;gt;&lt;/span&gt;netstandard2.0&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;TargetFramework&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;PropertyGroup&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;ItemGroup&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;ProjectReference&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;Include&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;..\A\A.csproj&amp;quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;ItemGroup&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;Project&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ここで、 B に対して &lt;code&gt;dotnet pack&lt;/code&gt; を実行したときの nuspec の &lt;code&gt;&amp;lt;dependencies&amp;gt;&lt;/code&gt; はこのようになります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;targetFramework&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;.NETStandard2.0&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;A&amp;quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;version&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;1.0.0&amp;quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;exclude&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Build,Analyzers&amp;quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;group&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;version=&quot;1.0.0&quot;&lt;/code&gt; という指定は、「1.0.0 以上」と解釈されます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_目標設定&quot;&gt;目標設定&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ここでは、 Semantic Versioning という前提で、 B が依存するのは A v1.0.0 以上 2.0.0 未満、としましょう。こうすれば、 B が A の Public API のみに依存しているならば、 B はこの依存関係が解決できる限り、必ず動作するといえます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_一筋縄で実現できたらブログ書いてない&quot;&gt;一筋縄で実現できたらブログ書いてない&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;はい。これは NuGet の Issue (&lt;a href=&quot;https://github.com/NuGet/Home/issues/5556&quot;&gt;NuGet/Home#5556&lt;/a&gt;) に挙がっており、現在も実現されていません。しかし頑張ればできないこともない状況になっています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;必要なものは &lt;a href=&quot;https://dotnet.microsoft.com/download/dotnet/5.0&quot;&gt;.NET 5.0 Preview SDK&lt;/a&gt; (執筆時点で 5.0.100-preview.3.20216.6) です。最新の NuGet を搭載している SDK を使うと、 csproj に少し手を入れるだけで、 &lt;code&gt;&amp;lt;ProjectReference&amp;gt;&lt;/code&gt; に対する依存関係に介入できるようになります。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_目標をクリアする_csproj&quot;&gt;目標をクリアする csproj&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;仕組みとかいいからとりあえず使いたいって人は、これをコピペしてください。バージョンの指定方法は、 NuGet のドキュメント (&lt;a href=&quot;https://docs.microsoft.com/ja-jp/nuget/concepts/package-versioning#version-ranges&quot;&gt;Version ranges&lt;/a&gt;) を確認してください。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;Project&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;Sdk&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Microsoft.NET.Sdk&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;PropertyGroup&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;TargetFramework&lt;/span&gt;&amp;gt;&lt;/span&gt;netstandard2.0&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;TargetFramework&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;PropertyGroup&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;ItemGroup&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;ProjectReference&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;Include&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;..\A\A.csproj&amp;quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;ItemGroup&lt;/span&gt;&amp;gt;&lt;/span&gt;

  &lt;span class=&quot;hljs-comment&quot;&gt;&amp;lt;!-- 以下を追加 --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;Target&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;Name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;SetDependencyVersion&amp;quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;AfterTargets&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;_GetProjectReferenceVersions&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;ItemGroup&lt;/span&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;_ProjectReferencesWithVersions&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;Update&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;..\A\A.csproj&amp;quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;ProjectVersion&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;[1.0.0,2.0.0)&amp;quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;ItemGroup&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;Target&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;Project&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;出力される nuspec の &lt;code&gt;&amp;lt;dependencies&amp;gt;&lt;/code&gt; はこんな感じになります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;targetFramework&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;.NETStandard2.0&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;A&amp;quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;version&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;[1.0.0, 2.0.0)&amp;quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;exclude&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Build,Analyzers&amp;quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;group&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_仕組み&quot;&gt;仕組み&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;dotnet pack&lt;/code&gt; (MSBuild で &lt;code&gt;Pack&lt;/code&gt; ターゲットを実行する) では、 &lt;code&gt;&amp;lt;ProjectReference&amp;gt;&lt;/code&gt; Item があったら、そのプロジェクトのバージョンを読み込み、 &lt;code&gt;&amp;lt;_ProjectReferencesWithVersions&amp;gt;&lt;/code&gt; という Item を作成します。そこで、その処理が行われる &lt;code&gt;_GetProjectReferenceVersions&lt;/code&gt; ターゲットの後に、読み込まれたバージョンを上書きするようなターゲットを作成することで、好きなバージョンに書き換えることができます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ここまでは古い SDK でもできたのですが、古い SDK では &lt;code&gt;ProjectVersion&lt;/code&gt; 属性にバージョンの&lt;strong&gt;範囲&lt;/strong&gt;が指定されることを想定していませんでした。つまり &lt;code&gt;1.0.0&lt;/code&gt; は受け付けるけど、 &lt;code&gt;[1.0.0,2.0.0)&lt;/code&gt; は受け付けてくれなかったわけです。新しい SDK では、範囲を指定してもエラーにならないようになったので、このようなハックでお茶を濁せるようになりました。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_今後もっと簡単になるか&quot;&gt;今後もっと簡単になるか？&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/NuGet/Home/issues/5556&quot;&gt;NuGet/Home#5556&lt;/a&gt; を監視していきましょう。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_nuget_に対するぼやき&quot;&gt;NuGet に対するぼやき&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;依存関係解決の戦略がデフォルトで「条件を満たす最小バージョン」な所為で、依存バージョンをすぐ「以上」にしてしまうのは NuGet の悪いところだなぁと思っています。そのおかげで lock ファイルを使わなくても、あまり崩壊しないという利点はありますが、少なくともリビジョンリリースは自動で最新にしてほしくない？ という思いがあります。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[さよならはてなブログ、こんにちはGatsby]]></title><description><![CDATA[Qiita 騒動で脱 Qiita といって静的サイトジェネレータに向き合うみなさん、こんにちは。私はほとんど Qiita に書いていない、根っからのはてなブログユーザーだったのですが、以前からいくつかの理由で脱はてなブログしたいなぁ～と考えており、本日ついに、自前のブログ基盤ができたので、移行していきたいと思います！


一発目の記事ということで、ブログの要件と、それに合わせてどうツールを選んだのかについて、書き残しておきたいともいます。]]></description><link>https://blog.azyobuzi.net/2020/04/04/01-hello-gatsby/</link><guid isPermaLink="false">https://blog.azyobuzi.net/2020/04/04/01-hello-gatsby/</guid><pubDate>Fri, 03 Apr 2020 17:29:00 GMT</pubDate><content:encoded>&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Qiita 騒動で脱 Qiita といって静的サイトジェネレータに向き合うみなさん、こんにちは。私はほとんど Qiita に書いていない、根っからのはてなブログユーザーだったのですが、以前からいくつかの理由で脱はてなブログしたいなぁ～と考えており、本日ついに、自前のブログ基盤ができたので、移行していきたいと思います！&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一発目の記事ということで、ブログの要件と、それに合わせてどうツールを選んだのかについて、書き残しておきたいともいます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_なぜ脱はてなブログ&quot;&gt;1. なぜ脱はてなブログ&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;URL の永続化&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;簡単に言えば、独自ドメインが良かった。例えば、はてなブログが突然サービスを終了すると言い出したら、今までの記事の URL は無効になってしまいます。そこで、独自ドメインに載せておけば、いざというときに URL を破壊せず、移行することができます。しかし、はてなブログ Pro は、少なくとも私のブログの利用状況に対して、料金が高い。高いよぉ。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;とはいえ、もうすでにはてなブログに投稿してしまった分はどうしようもないので、このままにしておきます。もしサービスが終了するようなことがあって、私がまだ生きていたら、いくつかはこのドメイン下にコピーして来ようと思います。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;マークアップ言語&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;はてな記法は悪くないけど、 &lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt; タグを書きまくるのはつらかった。一方で Markdown は、はてな記法より表現力が低くて、あまり楽しく書けませんでした。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（広告のロードが遅いので、全体的に遅く感じる）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;なぜ Qiita ではないのか&lt;/p&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Qiita なんて承認欲求が通常のブログより満たせる以外のメリット何一つないのに、その一点のメリットに負けた人たちが使うサービスでしょゲラゲラって言ってる&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; &lt;a href=&quot;https://mstdn.maud.io/@azyobuzin/103884235813994300&quot;&gt;@azyobuzin@mstdn.maud.io&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_このブログの技術構成&quot;&gt;2. このブログの技術構成&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;上記の要件を踏まえて、マークアップ言語に AsciiDoc（処理系として &lt;a href=&quot;https://github.com/asciidoctor/asciidoctor.js&quot;&gt;Asciidoctor.js&lt;/a&gt;）を、静的サイトジェネレータに &lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;Gatsby&lt;/a&gt; を選択しました。本当は、管理画面とか欲しいので、静的サイトじゃないほうが好きなのですが、バージョン管理を考えると、実装したくないなぁという気持ちになりました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;デザインについては &lt;a href=&quot;https://milligram.io/&quot;&gt;Milligram&lt;/a&gt; を使用しました。もともとは 1 から CSS を組んでいたのですが、 Asciidoctor が要求する要素が多すぎて面倒になって、 CSS フレームワークに乗せました。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_なぜ_asciidoc&quot;&gt;3. なぜ AsciiDoc&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;なぜ Markdown ではないのか。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;プレーンな Markdown （GitHub Flavored ではない）を思い出してください。機能が何もかも足りていないですね。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Markdown 処理系を思い出してください。いくつ方言があるんだよお前ら。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;というわけで、プレーンな Markdown は弱すぎ、方言はみんなバラバラ、 Markdown 対応サービス間でもコピペしたあとに修正を加えるなんて日常茶飯事な、そんなマークアップ言語で書きたくはありません。そこで、もともと機能が豊富で、さらに要素の拡張方法も仕様に含まれている AsciiDoc を採用することにしました。機能豊富なぶん、 HTML への変換結果と、それに必要なスタイルシートがつらいという問題はありますが、該当機能を使うまでは問題を先延ばしにできます。先延ばしていけ。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_なぜ_gatsby&quot;&gt;4. なぜ Gatsby&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Gatsby、こいつだけはないなと思っていたツールでした。それなのに今は……。そういうラブコメ好きですよ。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;静的サイトジェネレータといえば、 Jekyll を筆頭に、有名なものがいくつかありますが、大体どれも共通の問題があり、それは Frontmatter（文書の先頭の &lt;code&gt;---&lt;/code&gt; から始まる YAML ブロック）が必要ということです。こっちは AsciiDoc で書くつもりですから、そもそも Header Attribute という機能があります。それにも関わらず、 Jekyll も Hugo も Frontmatter を使うんです。許さない。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;そんな状況なので、既存の静的サイトジェネレータに嫌気がさして、自作を始めましたが、ブログとなるとトップページの記事一覧を作ったり、タグがあったりと考えることが多い上、 HTML テンプレートの処理系に与えるヘルパー関数すら無い状況からのスタートだったので、疲れて飽きてしまいました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;そこで、改めて AsciiDoc を使える静的サイトジェネレータを調べていたとき、 Gatsby + AsciiDoc の組み合わせを見て、ふと Gatsby で AsciiDoc を読み込むプラグインである &lt;a href=&quot;https://github.com/gatsbyjs/gatsby/tree/master/packages/gatsby-transformer-asciidoc&quot;&gt;gatsby-transformer-asciidoc のソースコード&lt;/a&gt;を読んでみたら、「なんだ、 Gatsby いいじゃん」となって、今に至ります&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;なぜ今まで Gatsby を避けてきたかというと、それはもう人々が声高に React！ PWA！ GraphQL！ モダン！ と叫んでいたからです。バズワードで埋め尽くされた、目的に対して無駄に遠回りなツールだと思っていました。こっちは 静的 HTML を吐き出したいんだ。静的と言いながらブラウザに大量のスクリプトを吐き出させるなんてごめんだという気持ちです。しかし、ちゃんと調べてみたら、まぁ無駄に遠回りなところもありますが、悪くないツールだということがわかりました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_静的サイトジェネレータで_graphql_ってどういうこと&quot;&gt;4.1. 静的サイトジェネレータで GraphQL ってどういうこと？&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Gatsby の基本的な設計は、&lt;a href=&quot;https://www.gatsbyjs.org/docs/gatsby-lifecycle-apis/#high-level-overview&quot;&gt;ライフサイクルの図&lt;/a&gt;がわかりやすいのですが、次のようになっています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;入力データを集める&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;入力データを View に合わせて整形する&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;View をレンダリングする&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;「入力データを集める」では、このブログで言えば、ブログの設定や、記事のファイルがあります。ほかには、例えば時事的な内容で考えると、コロナウィルスの感染状況のオープンデータ（ローカルファイルまたは外部リソースとしてダウンロードしてくる）を入力とする、というのが考えられますね。そして、集めたデータを View、ここでは React に渡して、ブラウザで表示できる形式に変換します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;では、この流れの中のどこで GraphQL が登場するのかというと、それは、集めた入力データが「オブジェクトの森」として表され、この森の中から、 View に必要なデータを過不足なく取得するときの記述方法として、 GraphQL が向いている、という話になります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_入力データを集める&quot;&gt;4.1.1. 入力データを集める&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;入力データは、さまざまな形式であることが考えられるので、プラグイン機構によって柔軟に処理できることが求められます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;入力データを集めるだけでも、データソースからの取得と、データの解釈の 2 種類があります。前者は、ファイルシステムやインターネットからデータを取得してきます。後者は、例えば、データが Markdown なら、 Frontmatter を処理したり、 HTML に変換したりして、バイト列から View で使える意味のあるデータに変形します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;さて、この取得・解釈パイプラインにおいて、ひとつのデータについて、ひとつの解釈とは限りません。複数のプラグインが同じデータを異なる方法で解釈することもあります。つまり、まっすぐなパイプラインにはなりません。そこで Gatsby が採用した、共通の入力データ形式は「オブジェクトの森」でした。あるデータに対する解釈は、そのデータの子オブジェクトになる、と表現します（&lt;a href=&quot;#image-forest-example&quot;&gt;Figure 1&lt;/a&gt;）。このような表現を用いることで、非常に柔軟に入力データを扱うことができるようになりました。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;image-forest-example&quot; class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/a/azyobuzin/20200403/20200403235038.png&quot; alt=&quot;データと、データの解釈結果オブジェクト&quot; width=&quot;500&quot;&gt;
&lt;/div&gt;
&lt;div class=&quot;title&quot;&gt;Figure 1. データと、データの解釈結果オブジェクト&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;さて、ここで入力データを集めてできたオブジェクトの森をどのように扱うか、というのが鍵になります。静的サイトなので、 DB を使うことはできませんから、サイト生成時に集めてきた情報を、ページごとに、表示に必要なだけ抽出する必要があります。そこで、 JavaScript Way ということで、抽出してきたデータが JSON 形式なっていると考えましょう。すると、 JSON を入力とする React コンポーネントを作れば、レンダリングができそうですね。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_graphql_と_gatsby_のビルドプロセス&quot;&gt;4.2. GraphQL と Gatsby のビルドプロセス&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;必要なものは、オブジェクトの森からデータを取り出し、 JSON を作成する方法だということがわかりました。そこで満を持して GraphQL の登場です。 GraphQL はオブジェクトの森に対して柔軟なクエリを記述でき、出力が JSON となります。完璧にマッチしますね。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;では、どのタイミングで、どのクエリが呼び出されるのでしょうか。答えは、ビルド時にすべてのクエリです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;まず、 Gatsby をまだ触っていない方のために、クエリの書き方を紹介します。あるページ &lt;code&gt;/hoge&lt;/code&gt; に対応する &lt;code&gt;pages/hoge.js&lt;/code&gt; があったとして、次のように、 &lt;code&gt;query&lt;/code&gt; または &lt;code&gt;pageQuery&lt;/code&gt; を &lt;code&gt;export&lt;/code&gt; することでクエリを指定すると、 &lt;code&gt;export default&lt;/code&gt; している関数の引数に &lt;code&gt;data&lt;/code&gt; として、そのクエリの結果が代入されます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;hoge.js&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; React &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;react&amp;#x27;&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; { graphql } &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;gatsby&amp;#x27;&lt;/span&gt;

&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;{ data }&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; title = data.site.siteMetadata.title
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;{title}&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;)
}

&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; query = graphql&lt;span class=&quot;hljs-string&quot;&gt;`
  query HogePage {
    site {
      siteMetadata {
        title
      }
    }
  }
`&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;または、 &lt;a href=&quot;https://www.gatsbyjs.org/docs/static-query/&quot;&gt;StaticQuery&lt;/a&gt; コンポーネントを使うことができます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;これをビルドツールの観点から見ると、実行するべきクエリは、すべてのページの &lt;code&gt;query&lt;/code&gt; または &lt;code&gt;pageQuery&lt;/code&gt;、それと、一度だけ各ページをレンダリングしてみることで、 &lt;code&gt;StaticQuery&lt;/code&gt; から取得することができます。 Gatsby は、このようにすべてのクエリを収集し、クエリ結果を JSON ファイルとして保存します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;結果がすべて JSON ファイルとして保存してあると、 Gatsby の特徴である、静的ページの生成と、 Single Page Application の両立をすることができます。 SPA において、 GraphQL クエリ部分が、実行済みクエリ結果をダウンロードするよう振る舞えば、それ以外はただの React アプリになっているので、普通に React の SPA になってしまうのです。そして静的ページ生成は、 React の Server Side Rendering を行うだけになります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;というわけで、なぜ静的サイトジェネレータが GraphQL とかいう大層なものを取り出したのか、までつながりました。納得すると、 Gatsby 悪くないなと思えてきました。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_ここがつらいよ_gatsby&quot;&gt;5. ここがつらいよ Gatsby&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;このブログの構築に必要だったワークアラウンド集です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_ブラウザにとって静的なサイトになりたい&quot;&gt;5.1. ブラウザにとって静的なサイトになりたい&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Gatsby がなぜ GraphQL を使っているのかについては、納得しました。しかし私が作りたいのは React でできたサイトではなく、ブログ本文が書かれた HTML が置いてあるだけのシンプルなブログです。 PWA でプリロード？ 知らん、読むかもわからんページを先読みしたところでたかが知れてるし、そのスクリプト分だけデータ量は増え、ブラウザの負荷もあります。エコじゃない。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;しかしまぁ、一応は Server Side Rendering 済み HTML が吐き出されるので、やりようでどうにかできます。 &lt;a href=&quot;https://www.gatsbyjs.org/packages/gatsby-plugin-no-javascript/&quot;&gt;gatsby-plugin-no-javascript&lt;/a&gt; という過激な名前のサードパーティープラグインがあり、吐き出される HTML の &lt;code&gt;script&lt;/code&gt; タグを全部消し去ります。今は特に動的な部分はないので、これで満足しています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;あと、 SPA という前提に立っているので、デフォルトでは CSS が HTML の &lt;code&gt;style&lt;/code&gt; タグに全部入っています。外部リソースのダウンロードを減らす目的でしょうけれど、スクリプトを無効化すると、サイト内リンクは React 内でのルーティングではなく普通のリンクになるので、各ページに CSS が埋め込まれていると逆効果になりそうです。そこで &lt;code&gt;style&lt;/code&gt; タグではなく &lt;code&gt;link&lt;/code&gt; タグにしておきたいです。 &lt;code&gt;link&lt;/code&gt; タグへの変換は、ビルド中のフックで、簡単にできます（&lt;a href=&quot;https://github.com/gatsbyjs/gatsby/issues/1526#issuecomment-583740341&quot;&gt;元ネタ&lt;/a&gt;）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;gatsby-ssr.js&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;undefined highlight&quot;&gt;&lt;code data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; React = &lt;span class=&quot;hljs-built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;react&amp;#x27;&lt;/span&gt;)

&lt;span class=&quot;hljs-built_in&quot;&gt;exports&lt;/span&gt;.onPreRenderHTML = &lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;{ getHeadComponents, replaceHeadComponents }&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {
  replaceHeadComponents(getHeadComponents().map(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;el&lt;/span&gt; =&amp;gt;&lt;/span&gt; {
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (el.type !== &lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;style&amp;#x27;&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; el
    &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; href = el.props[&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;data-href&amp;#x27;&lt;/span&gt;]
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; href
      ? (&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;rel&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;stylesheet&amp;#x27;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;{href}&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;)
      : el
  }))
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_公式の_asciidoc_プラグインでは満足できない&quot;&gt;5.2. 公式の AsciiDoc プラグインでは満足できない&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Gatsby で AsciiDoc を扱うには、公式より &lt;a href=&quot;https://www.gatsbyjs.org/packages/gatsby-transformer-asciidoc/&quot;&gt;gatsby-transformer-asciidoc&lt;/a&gt; プラグインが提供されており、これを使うのが一般的だと思います。しかし、 Header Attribute の取得があまり自由にできず、 &lt;code&gt;page-&lt;/code&gt; から始まる Header Attribute しか取得できません。これは、 Asciidoctor が使用するような AsciiDoc 的に一般的に用いられる属性と合わせられないという問題のほかに、まだ実装していませんが、数式表示が必要かを表す &lt;code&gt;:stem:&lt;/code&gt; を取得できないと、数式レンダリングライブラリをロードするべきかの判断ができない問題もあります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;この問題については、 gatsby-transformer-asciidoc の代わりを、適当に自作することにしました。 Asciidoctor.js を呼び出すだけなので、そんなに大がかりではありません。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_を含むパス問題&quot;&gt;5.3. 「#」を含むパス問題&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;私のブログなので、今後「C#」といったタグをつけた記事が出てくることが予想されるので、先に実験しておきました。タグのパスは &lt;code&gt;/tags/:tag&lt;/code&gt; の形式なのですが見事に死亡しました。「#」をエスケープすると 404 になり、エスケープしないとブラウザがフラグメント扱いします。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;結局、 &lt;a href=&quot;https://www.gatsbyjs.org/docs/actions/#createPage&quot;&gt;&lt;code&gt;createPage&lt;/code&gt;&lt;/a&gt; に渡すパスはエスケープせず、 &lt;a href=&quot;https://www.gatsbyjs.org/docs/gatsby-link/&quot;&gt;&lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt;&lt;/a&gt; に渡すパスはエスケープすることでお茶を濁しました。この方法では、静的サイトとして振る舞う場合は問題なく動作しますが、 SPA として振る舞う場合は死にます。より良い方法があれば教えてください。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;追記: Netlify にデプロイしようとしたら「Deployed filenames cannot contain # or ? characters」と怒られてしまいました。静的ファイルをホスティングするだけの分際で無駄な忖度をするんじゃないという気持ちになったので、 Vercel に移行しました。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_さいごに&quot;&gt;6. さいごに&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;下手な既存ツールで満足できない人間が、自前でブログを構築しようとすると、要求が膨らんで大変だということがよくわかりました。そんな中で、妥協点として Gatsby を採用しました。いくらか不満はありますが、解決できるだけの柔軟性はあるので、これからも仲良くやっていきたいと思います。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ブログを構築しようとして、何日を無駄にしたのでしょう。この 4 月より大学院に進学し、これから 2 年間どんな研究をするのかを考える大事な時期に、研究（文献調査）の進捗が出ていません。そんな時期に現実逃避していたら、数年の悲願であった自作ブログ基盤ができてしまいました。せっかくブログを作ったので、いろいろアウトプットできたらいいなぁと思います。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content:encoded></item></channel></rss>