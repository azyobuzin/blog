<!DOCTYPE html><html lang="ja" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="generator" content="https://github.com/azyobuzin/blog"><link rel="stylesheet" href="https://unpkg.com/fork-awesome@~1.2.0/css/fork-awesome.min.css" crossorigin="anonymous" referrerpolicy="no-referrer"><link rel="stylesheet" href="/global.css"><meta property="og:site_name" content="あじょろぐ"><meta name="twitter:card" content="summary"><meta name="twitter:creator" content="@azyobuzin"><title>tech | あじょろぐ</title><link rel="canonical" href="https://blog.azyobuzi.net/tags/tech/"><meta property="og:url" content="https://blog.azyobuzi.net/tags/tech/"><link rel="alternate" href="/tags/tech/feed.atom" type="application/atom+xml"><style>#tbl-interlaced-pred th, #tbl-interlaced-pred td:first-child, #tbl-nz51 td, #tbl-nz52 td {
  text-align: center;
} #tbl-interlaced-pred table, #tbl-nz51 table, #tbl-nz52 table {
  white-space: nowrap;
}</style><link rel="stylesheet" href="https://unpkg.com/katex@0.15.6/dist/katex.min.css" crossorigin="anonymous" referrerpolicy="no-referrer"><script src="https://unpkg.com/katex@0.15.6/dist/contrib/copy-tex.min.js" crossorigin="anonymous" referrerpolicy="no-referrer" async></script></head><body><div class="container"><header><h1>tech</h1><p class="breadcrumb" role="list"><span role="listitem"><a href="/">ホーム</a></span> > <span role="listitem" aria-current="page"><i class="fa fa-tag" title="タグ"></i> tech</span></p></header><main><div class="article-list" role="feed"><article class="article-list-item"><div class="article-list-item-content"><header><h1><a href="/2022/12/31/01-pgrman/">PostgreSQLをpg_rmanでちゃんとバックアップしている話</a></h1><div class="article-meta"><i class="fa fa-pencil-square-o" title="公開日"></i> <time datetime="2022-12-31T23:26+09:00" title="公開: 2022/12/31 23:26
最終更新: 2022/12/31 23:37">2022/12/31</time></div><div class="article-meta"><i class="fa fa-tags" title="タグ"></i><ul class="article-tags"><li><a rel="tag" class="article-tag" href="/tags/tech/">tech</a></li></ul></div></header><div class="article-content"><p>データベースの運用は難しい。私の運用している Pleroma (Mastodon 互換といえば世間的に通じそう) サーバー (<a href="https://xxx.azyobuzi.net/">ご隠居</a>) は、今まで EC2 + RDS の構成でしたが、さすがに高かった ($50 が円安で厳しくなっていく)。そこで 10 月に KAGOYA CLOUD VPS に移行を行いました。で、登録したら「嘘の住所で登録してない？」とサポートに疑われて、メールチェックしてない間にアカウントが停止されていたのは別の話……。</p>
<p>VPS に移行すると、データベースの管理も当然自分でやることになります。今まで RDS が自動でやっていたことを自分で組み直すのは大変だったので、今年最後の技術ブログをやっておきます。</p>
<p><a href="/2022/12/31/01-pgrman/">続きを読む</a></p></div></div></article><article class="article-list-item"><div class="article-list-item-content"><header><h1><a href="/2022/07/23/01-tokyopc/">一発屋サービス「東京極座標」をリリースしました</a></h1><div class="article-meta"><i class="fa fa-pencil-square-o" title="公開日"></i> <time datetime="2022-07-23T23:41+09:00" title="公開: 2022/07/23 23:41
最終更新: 2022/07/23 23:49">2022/07/23</time></div><div class="article-meta"><i class="fa fa-tags" title="タグ"></i><ul class="article-tags"><li><a rel="tag" class="article-tag" href="/tags/tech/">tech</a></li><li><a rel="tag" class="article-tag" href="/tags/Web/">Web</a></li></ul></div></header><div class="article-content"><p>みなさんは東京の土地勘ありますか？ 私は東京で生まれ育ちましたが、未だに赤坂がどこにあるのかいまいちピンと来ません。ただ都心であることは間違いないでしょう。</p>
<p>東京の中心は、言わずもがな、かつての江戸城、現在の皇居です。道路や鉄道は皇居を中心とした同心円状に整備されています。例えば、道路では、環状1～8号線、首都高都心・中央線環状線があります。東京メトロの主要な路線は、東京23区の端から、皇居を半周して、山手線の駅に繋がるような構成になっています。</p>
<p>逆に言えば、皇居は不可侵の場所です。皇居の上を越えていくことはできません。したがって、東京を攻略するには皇居をどっちまわりで抜けていくかを知ることが重要であり、そのためには目的地が皇居からみてどの方角にあるかを知る必要があります。</p>
<p>そこで私はかねてからアイデアがありました。東京はもう住所を廃止して極座標（皇居から見た方角と、皇居からの距離）で表すべきだと。</p>
<p>そしてついに、これを簡単に実現する Web サービスをつくりました！！！</p>
<p><a href="https://tokyopc.azyobuzi.net/">東京極座標 https://tokyopc.azyobuzi.net/</a></p>
<figure class="fig-img">
<img src="https://blog.azyobuzi.net/2022/07/23/01-tokyopc/akasaka.png" loading="lazy" alt="赤坂駅は皇居から 2.08km, -142° の位置にある" width="604" height="584">
</figure>
<p>このサービスのおかげで、赤坂が皇居の南西2kmにあることがわかりました！ このことから、赤坂のお高いイメージは皇居に近いことが影響しており、また普段なぜ縁がない場所かといえば、私は総武線（皇居をの北側を通って東西へ抜ける）沿線の民なので南西方向に行かないからということがわかります。このように東京極座標は、東京攻略を有利にすることができるのです。</p>
<p><a href="/2022/07/23/01-tokyopc/">続きを読む</a></p></div></div></article><article class="article-list-item"><div class="article-list-item-content"><header><h1><a href="/2022/01/11/01-cocbo/">クラスタサイズを指定できるk-meansベースのクラスタリング手法を実装した話</a></h1><div class="article-meta"><i class="fa fa-pencil-square-o" title="公開日"></i> <time datetime="2022-01-11T18:06+09:00" title="公開: 2022/01/11 18:06
最終更新: 2022/02/05 01:27">2022/01/11</time></div><div class="article-meta"><i class="fa fa-tags" title="タグ"></i><ul class="article-tags"><li><a rel="tag" class="article-tag" href="/tags/tech/">tech</a></li><li><a rel="tag" class="article-tag" href="/tags/C%2B%2B/">C++</a></li></ul></div></header><div class="article-content"><p>あけましておめでとうございます。季節感もなにもないブログですが、修論締切間近の時期に研究で使った技術をまとめようという点は季節感かもしれません。</p>
<p>今回のネタは、クラスタサイズに制約を設けてクラスタリングをしようという話です。</p>
<p>クラスタリングといったら、もっとも代表的な手法は k-means です。 k-means は<b>クラスタ数</b>を事前に指定して、クラスタリングを行います。つまり、 k-means を使うときは、データを <var>k</var> 個に分けたら何か傾向が見えるかもな～という気持ちで使うことになります。このとき、1クラスタに属するデータ数（<b>クラスタサイズ</b>）は、クラスタごとに異なります。</p>
<p>では、クラスタサイズを事前に指定するような方法はないのでしょうか。データが大量にあるので、データを <var>c</var> 個に均等に分割して処理したいな～というときに、どうしたらいいのでしょうか。というわけで今日の論文紹介です。</p>
<ul>
<li><a href="https://www.jstage.jst.go.jp/article/fss/32/0/32_329/_article/-char/ja">最適化に基づくマージン付きサイズ均等クラスタリングアルゴリズム</a></li>
<li><a href="https://ieeexplore.ieee.org/document/8023341">Controlled-sized clustering based on optimization</a></li>
</ul>
<p>上が日本語版、下が英語版で、書いてあることは同じです。この論文では、クラスタサイズの基準 <var>K</var> と、クラスタサイズの下限 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder accentunder="true"><mi>K</mi><mo stretchy="true">‾</mo></munder></mrow><annotation encoding="application/x-tex">\underline{K}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;vertical-align:-0.2em;"></span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6833em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2em;"><span></span></span></span></span></span></span></span></span></span> 、上限 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>K</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{K}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span> を指定すると、クラスタサイズがこの範囲内に収まるようにいい感じにクラスタリングする方法が示されています。英語版では、このアルゴリズムを COCBO と呼んでいるので、この記事でも COCBO と呼んでいこうと思います。</p>
<p><a href="/2022/01/11/01-cocbo/">続きを読む</a></p></div></div></article><article class="article-list-item"><div class="article-list-item-content"><header><h1><a href="/2021/09/24/01-markdown/">結局ブログをMarkdownで書くことにした話</a></h1><div class="article-meta"><i class="fa fa-pencil-square-o" title="公開日"></i> <time datetime="2021-09-24T23:30+09:00" title="公開: 2021/09/24 23:30
最終更新: 2022/07/23 17:41">2021/09/24</time></div><div class="article-meta"><i class="fa fa-tags" title="タグ"></i><ul class="article-tags"><li><a rel="tag" class="article-tag" href="/tags/tech/">tech</a></li><li><a rel="tag" class="article-tag" href="/tags/Web/">Web</a></li></ul></div></header><div class="article-content"><p>blog.azyobuzi.net を開設して1年強、メンテナンスも AsciiDoc も面倒になってきて、はてなブログに戻るのもアリだなぁという気持ちが若干発生してきていました。そもそもブログ自体書いてないじゃん。はい。すいません。</p>
<p>AsciiDoc というか Asciidoctor を使うことに思うところがあり、 Gatsby + Asciidoctor.js という構成をやめ、 Markdown + お手製静的サイトジェネレータ という構成に変更したというお話です。</p>
<p>（AsciiDoc から Markdown への移行は9月の頭には完了していましたが、記事を書く余裕がなかったので、今書いています。）</p>
<p><a href="/2021/09/24/01-markdown/">続きを読む</a></p></div></div></article><article class="article-list-item"><div class="article-list-item-content"><header><h1><a href="/2021/08/28/01-xaexception/">Xamarin.Android アプリが例外で落ちるということ</a></h1><div class="article-meta"><i class="fa fa-pencil-square-o" title="公開日"></i> <time datetime="2021-08-27T03:24+09:00" title="公開: 2021/08/27 03:24
最終更新: 2021/09/24 23:30">2021/08/27</time></div><div class="article-meta"><i class="fa fa-tags" title="タグ"></i><ul class="article-tags"><li><a rel="tag" class="article-tag" href="/tags/tech/">tech</a></li><li><a rel="tag" class="article-tag" href="/tags/C%23/">C#</a></li><li><a rel="tag" class="article-tag" href="/tags/Android/">Android</a></li></ul></div></header><div class="article-content"><p>TL;DR: Xamarin.Android のグローバル例外ハンドラは <code>AppDomain.UnhandledException</code>。これで Java の例外も拾えます。ただし、例外が発生したスレッドによってはうまく拾えないケースがあり、現在修正中です（<a href="https://github.com/xamarin/xamarin-android/issues/6211">xamarin-android#6211</a>）。</p>
<p><a href="/2021/08/28/01-xaexception/">続きを読む</a></p></div></div></article><article class="article-list-item"><div class="article-list-item-content"><header><h1><a href="/2021/03/23/01-dataflowblock-without-buffer/">バッファのない PropagatorBlock はつくれないという話</a></h1><div class="article-meta"><i class="fa fa-pencil-square-o" title="公開日"></i> <time datetime="2021-03-23T03:44+09:00" title="公開: 2021/03/23 03:44
最終更新: 2021/09/27 19:22">2021/03/23</time></div><div class="article-meta"><i class="fa fa-tags" title="タグ"></i><ul class="article-tags"><li><a rel="tag" class="article-tag" href="/tags/tech/">tech</a></li><li><a rel="tag" class="article-tag" href="/tags/C%23/">C#</a></li></ul></div></header><div class="article-content"><p>また TPL Dataflow の話です。突然ですが、バッファのない PropagatorBlock って欲しくないですか？</p>
<p>例えば、複数の SourceBlock があって、それをひとつの SourceBlock として返したいとき。</p>
<pre><code class="language-cs"><span class="hljs-function">ISourceBlock&#x3C;T> <span class="hljs-title">CreateSource</span>()</span>
{
    IEnumerable&#x3C;ISourceBlock&#x3C;T>> sources = <span class="hljs-comment">/* ... */</span>;

    <span class="hljs-keyword">var</span> resultBlock = <span class="hljs-keyword">new</span> BufferBlock&#x3C;T>(<span class="hljs-keyword">new</span> DataflowBlockOptions() { BoundedCapacity = <span class="hljs-number">1</span> });
    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> s <span class="hljs-keyword">in</span> sources) s.LinkTo(resultBlock);

    <span class="hljs-keyword">return</span> resultBlock;
}
</code></pre>
<p>どうでしょう？ <code>resultBlock</code> は、1件はバッファに持ってしまうので、後段のブロックがどうであれ、ソースからは必ず1件多く取り出されてしまいます。</p>
<p>1件くらいいいじゃない？ それは <code>sources</code> 次第でしょう。</p>
<p>というわけで、本題のバッファのない PropagatorBlock が欲しい、ということです。もし <code>resultBlock</code> にバッファがなければ、 <code>CreateSource</code> の戻り値を利用する（リンクする）とき、初めて <code>sources</code> からデータが取り出されます。やりたいですね。</p>
<p><a href="/2021/03/23/01-dataflowblock-without-buffer/">続きを読む</a></p></div></div></article><article class="article-list-item"><div class="article-list-item-content"><header><h1><a href="/2020/10/11/01-flif/">画像可逆圧縮形式 FLIF についてのメモ</a></h1><div class="article-meta"><i class="fa fa-pencil-square-o" title="公開日"></i> <time datetime="2020-10-11T20:51+09:00" title="公開: 2020/10/11 20:51
最終更新: 2022/02/05 01:27">2020/10/11</time></div><div class="article-meta"><i class="fa fa-tags" title="タグ"></i><ul class="article-tags"><li><a rel="tag" class="article-tag" href="/tags/tech/">tech</a></li></ul></div></header><div class="article-content"><p><a href="https://flif.info/"><dfn>FLIF</dfn> (Free Lossless Image Format)</a> は、実用されている可逆圧縮形式としておそらく現在最強の圧縮手法です。実際、画像圧縮手法に関する最近の研究では、 FLIF が比較対象となることが多いように思われます。このブログ記事では、 FLIF がどのように圧縮を行っているのか、理解できた範囲で記録していきます。</p>
<p>ファイル形式としての特徴は、アルファチャンネル対応、 HDR (サブピクセルが8ビットより大きい) 対応、アニメーション対応と、現代的な画像形式として一般的な構成となっています。</p>
<p>圧縮手法としての特徴は、次の2点が挙げられます。</p>
<ol>
<li>色空間 (YCoCg) や画素値の範囲を変換することで、画素間の相関が大きくなり、効率よく符号化できるようにします。</li>
<li>エントロピー符号化に使用する確率分布の使い分け（コンテキスト）を入力画像から決定木の形式で学習します。</li>
</ol>
<p>FLIF は、すでに ImageMagick で実装されており、すぐに試すことができます。また、コーデックのリファレンス実装は GitHub にあります (<a href="https://github.com/FLIF-hub/FLIF">FLIF-hub/FLIF</a>)。</p>
<p>なお、現在 FLIF の開発はストップしており、 FLIF の成果は JPEG XL に取り込まれるようです。ただ <a href="https://gitlab.com/wg1/jpeg-xl/-/blob/bf10dc87f9b91cf2eb536b36362987a992b3c25f/doc/xl_overview.md#lossless">JPEG XL の説明</a>を読む限り、以上に挙げた特徴とは違っているので、手法としては別物になるのではないかと思っています。</p>
<p><a href="/2020/10/11/01-flif/">続きを読む</a></p></div></div></article><article class="article-list-item"><div class="article-list-item-content"><header><h1><a href="/2020/09/28/01-vs-docker-compose/">Visual Studio と VSCode どちらでも使える Docker Compose 環境</a></h1><div class="article-meta"><i class="fa fa-pencil-square-o" title="公開日"></i> <time datetime="2020-09-28T02:29+09:00" title="公開: 2020/09/28 02:29
最終更新: 2022/02/05 01:27">2020/09/28</time></div><div class="article-meta"><i class="fa fa-tags" title="タグ"></i><ul class="article-tags"><li><a rel="tag" class="article-tag" href="/tags/tech/">tech</a></li><li><a rel="tag" class="article-tag" href="/tags/C%23/">C#</a></li><li><a rel="tag" class="article-tag" href="/tags/Docker/">Docker</a></li></ul></div></header><div class="article-content"><p>開発環境を Docker でいい感じにしてくれるやつとして、 Visual Studio では「コンテナー開発ツール」が、 Visual Studio Code には Remote 拡張があります。これらは Dockerfile や docker-compose.yml を用意すると、その中でアプリを動かすことができるやつです。しかし、同じものではないので、挙動はまったく異なります。それぞれメリット、デメリットがあるので、両方使えるとうれしいわけです。そこで、うまいこと両方で使える docker-compose.yml を書いてみようという試みをやっていきます。</p>
<p><a href="/2020/09/28/01-vs-docker-compose/">続きを読む</a></p></div></div></article><article class="article-list-item"><div class="article-list-item-content"><header><h1><a href="/2020/09/14/01-cilium/">結局、理想のネットワークは Docker で実現できなかった</a></h1><div class="article-meta"><i class="fa fa-pencil-square-o" title="公開日"></i> <time datetime="2020-09-14T22:13+09:00" title="公開: 2020/09/14 22:13
最終更新: 2022/02/05 01:27">2020/09/14</time></div><div class="article-meta"><i class="fa fa-tags" title="タグ"></i><ul class="article-tags"><li><a rel="tag" class="article-tag" href="/tags/tech/">tech</a></li><li><a rel="tag" class="article-tag" href="/tags/Docker/">Docker</a></li></ul></div></header><div class="article-content"><p><a href="https://cilium.io/">Cilium</a> の Docker プラグインの導入を検討したものの、無理みがあった。ぱたり。</p>
<p><a href="/2020/09/14/01-cilium/">続きを読む</a></p></div></div></article><article class="article-list-item"><div class="article-list-item-content"><header><h1><a href="/2020/05/03/01-projectref/">ProjectReference にバージョン範囲を指定したい</a></h1><div class="article-meta"><i class="fa fa-pencil-square-o" title="公開日"></i> <time datetime="2020-05-03T04:07+09:00" title="公開: 2020/05/03 04:07
最終更新: 2021/09/24 23:30">2020/05/03</time></div><div class="article-meta"><i class="fa fa-tags" title="タグ"></i><ul class="article-tags"><li><a rel="tag" class="article-tag" href="/tags/tech/">tech</a></li><li><a rel="tag" class="article-tag" href="/tags/C%23/">C#</a></li></ul></div></header><div class="article-content"><p>複数のプロジェクトをひとつのリポジトリで管理するとき、プロジェクト間の参照関係は csproj に <code>&#x3C;ProjectReference></code> を書くわけですが、ここで、このプロジェクトを NuGet パッケージ化するときのことを考えます。例えば、 A と B というプロジェクトがあり、 B が A に依存しているとします。このとき B を <code>dotnet pack</code> してできあがるパッケージの A への依存はどのようになるでしょうか？ 実際にやってみると、現在の A のバージョン<strong>以上</strong>という依存関係になります。</p>
<p>ここで、 A の現在のバージョンを 1.0.0 とします。 Semantic Versioning に従っていると考えると、もし 2.0.0 がリリースされたら、破壊的な変更が入っているかもしれません。それでも B から A への依存は 1.0.0 <strong>以上</strong>で良いのでしょうか？ と考えると、「以上」以外の柔軟な依存関係を指定したくなりませんか？ というわけで、 <code>&#x3C;ProjectReference></code> を使ったプロジェクト間参照で、柔軟なバージョン範囲指定をしたいというのが今回のお話です。</p>
<p><a href="/2020/05/03/01-projectref/">続きを読む</a></p></div></div></article><article class="article-list-item"><div class="article-list-item-content"><header><h1><a href="/2020/04/30/01-reactivestreams/">プロトコルから比較する Reactive Streams と TPL Dataflow</a></h1><div class="article-meta"><i class="fa fa-pencil-square-o" title="公開日"></i> <time datetime="2020-04-30T02:36+09:00" title="公開: 2020/04/30 02:36
最終更新: 2022/02/05 01:27">2020/04/30</time></div><div class="article-meta"><i class="fa fa-tags" title="タグ"></i><ul class="article-tags"><li><a rel="tag" class="article-tag" href="/tags/tech/">tech</a></li><li><a rel="tag" class="article-tag" href="/tags/C%23/">C#</a></li></ul></div></header><div class="article-content"><p>以前、<a href="https://azyobuzin.hatenablog.com/entry/2019/05/26/164155">「<cite>いまさら使う TPL Dataflow</cite>」</a>で紹介した TPL Dataflow は、入力されたデータを並列に処理するプログラムを、ブロックの組み合わせで簡単に記述できるライブラリです。
<a href="https://azyobuzin.hatenablog.com/entry/2019/05/26/164155#%E9%A1%9E%E4%BC%BC%E5%93%81%E3%81%A8%E3%81%AE%E6%AF%94%E8%BC%83">「<cite>類似品との比較</cite>」</a>で述べたように、 TPL Dataflow は、プッシュ型とプル型の両方の性質を持っており、送信者（<i>Producer</i>）が、受信者（<i>Consumer</i>）が処理しきれないほど大量のデータをプッシュしようとするとき、受信者がそのデータの受信を遅延させることで、データフロー内を流れるデータ量を制御します。</p>
<p>一方で、このような、大量のデータや時系列データ（イベント列）を入力し、データフロー内を流れるデータ量を制御しながら、並列にデータを加工する仕組みは、一般的に、特に Java のコミュニティでは <a href="https://www.reactive-streams.org/"><dfn>Reactive Streams</dfn></a> と呼ばれています。 Reactive Streams に用いられるインターフェイスは Java 9 で <code>java.util.concurrent.Flow</code> として標準ライブラリ入りしており、 RxJava や Akka Streams がこのインターフェイスの実装を提供しています（実際には、互換性のため <a href="https://github.com/reactive-streams/reactive-streams-jvm">reactive-streams パッケージ</a>を通じて実装しています）。</p>
<p>C# においても Reactive Streams は他人事ではなく、 <code>java.util.concurrent.Flow</code> と同様のインターフェイスが <a href="https://github.com/reactive-streams/reactive-streams-dotnet">Reactive.Streams パッケージ</a>として NuGet で配布されており、標準的なインターフェイスの座を狙っています。また Akka.NET Streams がこのインターフェイスの実装を提供しています。</p>
<p>いずれの方法も、 Reactive Extensions (Rx) 的なプッシュ型に対して、流量制限（<i>back pressure</i>）を導入することで、データ量を制御しています。この記事では、 Reactive Streams と TPL Dataflow をプロトコル（インターフェイスとその実装方法）から比較します。</p>
<p><a href="/2020/04/30/01-reactivestreams/">続きを読む</a></p></div></div></article><article class="article-list-item"><div class="article-list-item-content"><header><h1><a href="/2020/04/04/01-hello-gatsby/">さよならはてなブログ、こんにちはGatsby</a></h1><div class="article-meta"><i class="fa fa-pencil-square-o" title="公開日"></i> <time datetime="2020-04-04T02:29+09:00" title="公開: 2020/04/04 02:29
最終更新: 2022/07/23 17:41">2020/04/04</time></div><div class="article-meta"><i class="fa fa-tags" title="タグ"></i><ul class="article-tags"><li><a rel="tag" class="article-tag" href="/tags/tech/">tech</a></li><li><a rel="tag" class="article-tag" href="/tags/Web/">Web</a></li></ul></div></header><div class="article-content"><p>Qiita 騒動で脱 Qiita といって静的サイトジェネレータに向き合うみなさん、こんにちは。私はほとんど Qiita に書いていない、根っからのはてなブログユーザーだったのですが、以前からいくつかの理由で脱はてなブログしたいなぁ～と考えており、本日ついに、自前のブログ基盤ができたので、移行していきたいと思います！</p>
<p>一発目の記事ということで、ブログの要件と、それに合わせてどうツールを選んだのかについて、書き残しておきたいともいます。</p>
<ins class="note ins-block" datetime="2021-09-24" role="note"><div class="note-heading">追記 <time datetime="2021-09-24">2021/09/24</time></div><div class="note-content">
<p>AsciiDoc をやめ Markdown に移行しました。</p>
<p><a href="https://blog.azyobuzi.net/2021/09/24/01-markdown/"><cite>結局ブログをMarkdownで書くことにした話</cite></a></p>
</div></ins>
<p><a href="/2020/04/04/01-hello-gatsby/">続きを読む</a></p></div></div></article></div></main><footer><nav><a href="/">あじょろぐ</a></nav></footer></div></body></html>