= React Hooks、あるいは FRP のための手続き型 DSL
:keywords: React

私が最初に React に触れたころ、まだ ES6 class を使わない書き方が一般的でした。コンポーネント指向の UI 構築は魅力的でしたが、結構面倒くさいな、そして mixin とか誰が理解できるんだよ、といった感想を持ちました。それからしばらく React を使う機会がなかったのですが、去年、一念発起して NW.js アプリをつくることになり、時代は Function Component で、状態管理には `useState` なるものを使うらしいと学びました。

それから、既存のカスタムフック（特に link:https://github.com/mobxjs/mobx[mobx-react]）の実装を呼んで挙動を理解し、応用しようとしたところで、 React Hooks という機能の強力さに気づきました。 link:https://ja.reactjs.org/docs/hooks-rules.html[Hooks Rules] から逸脱しない限り、強力かつ安全にライフサイクル管理ができます。特に特徴的なのが `useEffect` の第2引数に指定する依存オブジェクトリストです。これにより、いつ操作を行うか、ではなく、どのデータを起点に操作を行うか、で表現できるようになりました。

React の登場は Web 開発におけるパラダイムシフトでした。 React Hooks はどうでしょう？ 私は JavaScript の書き方やリアクティブプログラミングに対するパラダイムシフトなのではないかと考えています。

この記事では、この感動を伝えるため、 React Hooks のベースにある概念や、類似技術を紹介していきたいと思います。とはいえ React についても、関数型プログラミングについても、かなり浅い知識しかないため、正確さは期待しないでください。心の優しいプロの皆さんはマサカリを用意しておいてください。全力で白刃取りして知識をアップデートします。

== 視点1: Algebraic Effects にインスパイアされた？

* link:https://overreacted.io/ja/algebraic-effects-for-the-rest-of-us/[我々向けの Algebraic Effects 入門 — Overreacted]

上記の記事は React チームの中の人が書いた記事の日本語翻訳なので、かなり信憑性があります。この記事によれば、 Suspense や Hooks は Algebraic Effects にインスパイアされたということです。

実際、少し前に JavaScript 界隈が Algebraic Effects でざわざわしたことがありましたが、忘れてはいけないのは、インスパイアされただけで Algebraic Effects を JavaScript に実装したわけではないということです。

では何にインスパイアされ、どんなエッセンスを取り込んだのでしょうか。

=== Algebraic Effects and Handlers

Algebraic Effects 自体については先程の記事や、link:https://nymphium.github.io/2018/10/30/what-is-algebraic-effects.html[「Algebraic Effectsとは? 出身は? 使い方は? その特徴とは? 調べてみました! - lilyum ensemble」]が参考になると思いますが、ここでは先の説明に必要なだけ、ざっくりと説明します。フルネームでは and Handlers が付きますが、これも重要な視点です。

コンピュータは、当たり前ですが入出力をしながら計算を進めていきます。プログラムの中には、純粋な関数の組み合わせで行う計算と、入出力などプログラムの外に影響を及ぼす操作（副作用）が入り混じっています。純粋関数型言語界隈では、この入り混じった状況を良しとしない文化があり、前者と後者を分離するための仕組みをつくろうとしています。正直 Haskell はほとんど触ってないのであまり言及したくないのですが、 IO モナドはまさにそういうことです。

Algebraic Effects もその手法のひとつと言えます。関数を評価するときに純粋ではない操作（computional effect）を分離し、外側でその挙動を指定できる（つまり handler）ようにすることで、関数本体の合成、およびハンドラの差し替え・合成を可能にするというコンセプトです。「Algebraic Effects」は計算理論として効果をどう扱うか、そして「Handlers」によってプログラミングパラダイムになったと言えるのではないでしょうか。

手続き型に慣れている人々にわかりやすい例は、 Java の検査例外でしょうか？ 次のプログラムでは `foo` は `String` を返すか、または `BarException` をスローします。つまり純粋な関数として計算を行い `String` を返すかもしれないし、そうではない操作として `BarException` のスローを行うかもしれません。このとき、 `foo` を使う側は、通常の `return` と `throw BarException` が発生した場合の2通り（`throws` によって合成の様子が定義されていますね。このような足し算の合成ができるから「代数的」という理解なのですが、あってますか？）のハンドラを定義して待ち受けます。

[source,java]
----
String foo(int x) throws BarException {
    if (x == 1) return "わんっ！";
    throw new BarException();
}

String runFoo(int x, String ifError) {
    try {
        return foo(x)
    } catch (BarException e) {
        return ifError
    }
}
----

言いたいことは、これの一般化です。ここでは例外のスローという純粋ではない操作（効果）を例に上げましたが、他にも I/O や関数の外側にある状態を操作する、といった**効果の意味を、外側のハンドラに委譲**します。すると、効果を発生させる関数は、あくまでどのような計算を行い、どのような効果を発生させるかを宣言するだけの存在になるので、純粋と考えることができるようになります。なぜなら純粋ではない部分は外側で何とかしてくれるので……。

もう少しまともな説明をすると、継続渡しをするだとか、ハンドラが純粋なら純粋関数として評価できるとか、いろいろ言えますが、そろそろ React Hooks に戻りましょう。大事なことは、次の2点です。

. 純粋ではない操作を外部に委譲する仕組みがあると、純粋な部分とそうでない部分を分離できて便利
. 例外機構のある言語では try/catch で Algebraic Effects and Handlers の考え方の一部を実装している

=== 純粋ではない操作を React ランタイムに委譲する

React Hooks は何をしたかというと、 **Function Component が見かけ上純粋なままで、純粋ではない操作を書けるようにした**ということです。コンポーネント関数の中では `useState` と書くことで状態を使うという宣言をします。これが効果の発生と考えることができます。 React はその宣言を汲んでうまいことハンドルしてくれます。

`throw` をするとランタイムが外側のハンドラを呼び出してくれるように、 `await` をするとランタイムが実行を一時停止し Promise の完了後に再実行してくれるように、 `useState` をすると React が現在の状態を教えてくれるのです。これらはすべて Algebraic Effects の具象化といえるでしょう（それぞれが具象化なので React が Algebraic Effects を一般的に実装したわけではないということもわかると思います）。このような見方をすることで、一見奇妙に見えるフックの書き方も JavaScript を逸脱しない範囲で `throw` や `await` と同列の機能を実装したんだと理解することができますし、先程紹介した記事によれば、これはこじつけではなく、中の人が本当にそういうメンタルモデルで実装したということがわかると思います。

このような考え方を導入することで Class Component から何が変わったのでしょうか。次の2点が挙げられると思います。

. コンポーネントのライフサイクルのハンドリングが、コンポーネント自身から React のランタイムに移った
. 状態という巨大オブジェクトの解体

まずライフサイクルに関して。 Class Component ではライフサイクルイベントに対応するメソッド（`componentDidMount` や `componentWillUnmount`）をオーバーライドすることによってライフサイクルを制御していました。 Hooks を使った Function Component では、ライフサイクルをハンドリングするのではなく、必要な機能と依存関係を宣言するだけになりました。 React はその宣言をハンドリングすることで実際の操作を組み立てていきます。難しいことはランタイムに任せればいいという観点では、仮想 DOM と同じメンタルモデルとも言えるでしょう。

次に状態の解体。 Class Component における `render` 関数は `this.props` と `this.state` というふたつのオブジェクトを入力としていました。つまりコンポーネントと状態は 1 : 1 の関係でした。しかし Hooks では `useState` を複数回使用することで、ひとつのコンポーネントに複数の状態を紐づけることを許可しました。それで？と思うかもしれませんが、機能が細分化できるということは、再利用性が高まるのです。これは後付けの理由かもしれませんが、実際この特性を利用して、どんどん便利なカスタムフックが生まれています。そして、そのカスタムフックの作成も、非常にシンプルに、同じように React に面倒ごとを押し付けるだけで作れるのです。

React Hooks は Algebraic Effects の、副作用を外部のハンドラに追いやり、関数自体を純粋に保つというコンセプトを応用したものです。そしてそれを JavaScript として違和感のない関数呼び出しという形式に落とし込むことに成功しました。多少無理をしたので link:https://ja.reactjs.org/docs/hooks-rules.html[Hooks Rules] という制約はありますが、その制約を飲んででも使いたい魅力があるのではないでしょうか。

== 視点2: リアクティブプログラミングのための DSL という見方

何らかのイベントを受けて、仮想 DOM を作成し、 DOM に反映する、という一連の流れという点では React は最初からリアクティブプログラミングをしているし、そもそも React という名前がそうだろというのはごもっともですが聞いてください。 React Hooks によって手続き型的な書き方で Rx のような表現力を手に入れたのではないかという仮説があります。


