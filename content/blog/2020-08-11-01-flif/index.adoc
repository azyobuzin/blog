= 画像可逆圧縮手法 FLIF についてのメモ
:sectnums:
:xrefstyle: short

https://flif.info/[FLIF (Free Lossless Image Format)] は、実用されている可逆圧縮形式としておそらく現在最強の圧縮手法です。実際、画像圧縮手法に関する最近の研究では、 FLIF が比較対象となることが多いように思われます。このブログ記事では、 FLIF がどのように圧縮を行っているのか、理解できた範囲で記録していきます。

ファイル形式としての特徴は、アルファチャンネル対応、 HDR (サブピクセルが8ビットより大きい) 対応、アニメーション対応と、現代的な画像形式として一般的な構成となっています。

圧縮手法としての特徴は、次の2点が挙げられます。

. 色空間 (YCoCg) や画素値の範囲を変換することで、画素間の相関が大きくなり、効率よく符号化できるようにします。
. エントロピー符号化に使用する確率分布の使い分け（コンテキスト）を入力画像から決定木の形式で学習します。

FLIF は、すでに ImageMagick で実装されており、すぐに試すことができます。また、コーデックのリファレンス実装は GitHub にあります (https://github.com/FLIF-hub/FLIF:[FLIF-hub/FLIF])。

なお、現在 FLIF の開発はストップしており、 FLIF の成果は JPEG XL に取り込まれるようです。ただ https://gitlab.com/wg1/jpeg-xl/-/blob/bf10dc87f9b91cf2eb536b36362987a992b3c25f/doc/xl_overview.md#lossless:[JPEG XL の説明]を読む限り、以上に挙げた特徴とは違っているので、手法としては別物になるのではないかと思っています。

== 他の可逆圧縮手法との比較

（あんまり詳しくないので、ツッコミよろ）

現在 web でシェアを取っている PNG と WebP は、 Deflate のような辞書型圧縮が使用されています。 PNG は入力画像の画素値、または入力画像に何らかのフィルタをかけた画像の画素値を Deflate で圧縮します。 WebP の可逆圧縮モードでは隣接画素を使った画素値の予測をし、予測値の誤差（残差）を記録します。

FLIF は、隣接画素からの予測誤差を使用する点で WebP に近いですが、 WebP のような辞書型圧縮 + ハフマン符号の構成ではなく、算術符号で符号化を行います。算術符号については後で説明します。

算術符号を使用する手法としては、 JPEG 2000 や H.264 があります。これらの手法では、2値に対する算術符号が使用されています。 FLIF もこれらの手法を参考にしつつ、ギリギリ特許と被らない手法を使用しています。

== FLIF ファイルの構成

FLIF ファイルは、大きく次のように構成されます。区切り方は https://flif.info/spec.html:[FLIF16 Specification] に従っています。

Main Header:: 画像の大きさやチャンネル数が記述されます。
Metadata:: 任意のデータを書き込めます。ここに Exif とかを入れます。
Second Header:: 圧縮に使用するパラメータが記述されます。ここで色空間やその他の変換をするのか、するならば変換に使用するパラメータを記述します。
Pixel Data:: Second Header で指定した変換がなされた画像のデータです。後で詳しく説明します。

== 画素値の符号化

画素値の符号化には2種類の方法が用意されています。

非インターレース (Non-interlaced):: 上の画素から順番に符号化していきます。デフォルトでは、総画素数が1万未満のときに使用されます。
インターレース (Interlaced):: 画像を 1/2, 1/4, 1/8, …… と縮小していき、小さいものから順に符号化していきます。画素値を予測するときに、小さい画像の画素値を使って予測を行うことができるので、非インターレースではできないような予測（予測しようとしている画素の右下の画素を使う）ができます。

=== 非インターレース方式

非インターレース方式では、 Pixel Data パートは次のような構造になります。

. MANIAC 符号化 (後述) に使用する決定木
. チャンネルごとに、画素値を左上からラスタスキャンの順に MANIAC 符号化したデータ

実際に符号化する画素値は、予測された画素値との誤差になります。予測に使用する画素は、次に示すように、予測する画素 X の左上、上、左です。

+++
<pre> +---+---+
 | TL| T |
 +-------+
 | L | X |
 +---+---+</pre>
+++

予測値は、 L+T-TL, L, T の中央値です。 X-予測値 が実際に符号化される値になります。

アルファチャンネルがある場合、アルファチャンネルが一番最初に符号化されます。なぜなら、 Second Header の項目に、透明ピクセルのデータを捨てる（Aが0ならRGBの値は未定義にする）オプションがあるため、ある座標が透明ピクセルかどうかがわからないと他のチャンネルを符号化・複合化できないからです。アルファチャンネル以外については、 YCoCg はその順番で、 RGB は Second Header の変換で PermutePlanes が指定されているかどうかで決まります。

=== インターレース方式

大きいサイズの画像に対しては、非インターレース方式よりも複雑ですが、予測精度の高い手法を用いることで、圧縮効率を稼ぎます。インターレース方式では小さい画像から段々と大きい画像を復元していきます。

次の表は実際のデコード処理中のデータを Y チャンネル（輝度値）について取り出したものです。この場合では、ズームレベル 14 から順番に復元していきます。

|===
|ズームレベル |サイズ |画像

|0 |120×120 (原画像サイズ)
|image:interlace/dec_i01_fr00_z00_p00.png["ZL=0"]

|1 |120×60
|image:interlace/dec_i00_fr00_z01_p00.png["ZL=1"]

|2 |60×60
|image:interlace/dec_rough_i30_fr00_z02_p00.png["ZL=2"]

|3 |60×30
|image:interlace/dec_rough_i27_fr00_z03_p00.png["ZL=3"]

|4 |30×30
|image:interlace/dec_rough_i24_fr00_z04_p00.png["ZL=4"]

|5 |30×15
|image:interlace/dec_rough_i21_fr00_z05_p00.png["ZL=5"]

|6 |15×15
|image:interlace/dec_rough_i18_fr00_z06_p00.png["ZL=6"]

|7 |15×8
|image:interlace/dec_rough_i15_fr00_z07_p00.png["ZL=7"]

|8 |8×8
|image:interlace/dec_rough_i12_fr00_z08_p00.png["ZL=8"]

|9 |8×4
|image:interlace/dec_rough_i09_fr00_z09_p00.png["ZL=9"]

|10 |4×4
|image:interlace/dec_rough_i06_fr00_z10_p00.png["ZL=10"]

|11 |4×2
|image:interlace/dec_rough_i04_fr00_z11_p00.png["ZL=11"]

|12 |2×2
|image:interlace/dec_rough_i02_fr00_z12_p00.png["ZL=12"]

|13 |2×1
|image:interlace/dec_rough_i01_fr00_z13_p00.png["ZL=13"]

|14 |1×1
|image:interlace/dec_rough_i00_fr00_z14_p00.png["ZL=14"]
|===

具体的なアルゴリズムを書くと長くなるので、以上のように画素が埋まっていくんだなと解釈してください（雑）。最後のズームレベルは 1×1 になるので、より大きな画像ではズームレベルがさらに多くなります。また、横長、縦長の画像では、あるズームレベルで 1 ピクセルも復元されないことがあります（このケースにおいて、デフォルトのオプションで圧縮したときには特に無駄なデータが書き込まれたりはしませんが、オプションによっては 1 ズームレベルあたり数ビットを無駄にしているような気がします）。

このように圧縮すると何がうれしいかというと、すでにデコードされている隣接画素の情報を画素値予測に使うことができることができます。図からも 4×4 くらいになれば、手がかりになりそうなデータになっていることが分かると思います。実際、インターレース方式で使用する予測器は、非インターレース方式の予測器よりもリッチです。

TODO

== 符号化

=== 算術符号

=== 適応的算術符号

=== Near-zero 整数符号

=== コンテキストと決定木
